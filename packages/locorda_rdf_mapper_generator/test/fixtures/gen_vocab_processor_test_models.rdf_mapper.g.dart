// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/gen_vocab_processor_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations
// ignore_for_file: depend_on_referenced_packages

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'gen_vocab_processor_test_models.dart';
import 'package:locorda_rdf_terms_schema/schema.dart';

/// Generated mapper for [GenVocabBook] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `GenVocabBook`.
class GenVocabBookMapper implements GlobalResourceMapper<GenVocabBook> {
  static final RegExp _regex = RegExp(
    r'^https://example\.com/books/(?<id>[^/]*)$',
  );

  /// Constructor
  const GenVocabBookMapper();

  @override
  IriTerm? get typeIri =>
      const IriTerm('https://example.com/vocab#GenVocabBook');

  @override
  GenVocabBook fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String title = reader.require(
      const IriTerm('http://purl.org/dc/terms/title'),
    );
    final String displayTitle = reader.require(
      const IriTerm('https://example.com/vocab#displayTitle'),
    );
    final String isbn = reader.require(
      const IriTerm('https://example.com/vocab#isbn'),
    );

    return GenVocabBook(
      id: id,
      title: title,
      displayTitle: displayTitle,
      isbn: isbn,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    GenVocabBook resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('http://purl.org/dc/terms/title'),
          resource.title,
        )
        .addValue(
          const IriTerm('https://example.com/vocab#displayTitle'),
          resource.displayTitle,
        )
        .addValue(
          const IriTerm('https://example.com/vocab#isbn'),
          resource.isbn,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(GenVocabBook resource) {
    final id = resource.id;
    return 'https://example.com/books/${id}';
  }
}

/// Generated mapper for [GenVocabLibraryItem] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `GenVocabLibraryItem`.
class GenVocabLibraryItemMapper
    implements GlobalResourceMapper<GenVocabLibraryItem> {
  static final RegExp _regex = RegExp(
    r'^https://example\.com/library-items/(?<id>[^/]*)$',
  );

  /// Constructor
  const GenVocabLibraryItemMapper();

  @override
  IriTerm? get typeIri =>
      const IriTerm('https://example.com/vocab#GenVocabLibraryItem');

  @override
  GenVocabLibraryItem fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String title = reader.require(
      const IriTerm('https://example.com/vocab#libraryItemTitle'),
    );
    final String publicationDate = reader.require(
      const IriTerm('https://example.com/vocab#publicationDate'),
    );

    return GenVocabLibraryItem(
      id: id,
      title: title,
      publicationDate: publicationDate,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    GenVocabLibraryItem resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('https://example.com/vocab#libraryItemTitle'),
          resource.title,
        )
        .addValue(
          const IriTerm('https://example.com/vocab#publicationDate'),
          resource.publicationDate,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(GenVocabLibraryItem resource) {
    final id = resource.id;
    return 'https://example.com/library-items/${id}';
  }
}

/// Generated mapper for [GenVocabContract] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `GenVocabContract`.
class GenVocabContractMapper implements GlobalResourceMapper<GenVocabContract> {
  static final RegExp _regex = RegExp(
    r'^https://example\.com/contracts/(?<id>[^/]*)$',
  );

  /// Constructor
  const GenVocabContractMapper();

  @override
  IriTerm? get typeIri =>
      const IriTerm('https://example.com/contracts#GenVocabContract');

  @override
  GenVocabContract fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String title = reader.require(
      const IriTerm('http://purl.org/dc/terms/title'),
    );
    final String signedAt = reader.require(
      const IriTerm('https://example.com/contracts#signedAt'),
    );

    return GenVocabContract(id: id, title: title, signedAt: signedAt);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    GenVocabContract resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('http://purl.org/dc/terms/title'),
          resource.title,
        )
        .addValue(
          const IriTerm('https://example.com/contracts#signedAt'),
          resource.signedAt,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(GenVocabContract resource) {
    final id = resource.id;
    return 'https://example.com/contracts/${id}';
  }
}

/// Generated mapper for [GenVocabMultilingualProduct] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `GenVocabMultilingualProduct`.
class GenVocabMultilingualProductMapper
    implements GlobalResourceMapper<GenVocabMultilingualProduct> {
  static final RegExp _regex = RegExp(
    r'^https://example\.com/products/(?<id>[^/]*)$',
  );

  /// Constructor
  const GenVocabMultilingualProductMapper();

  @override
  IriTerm? get typeIri =>
      const IriTerm('https://example.com/vocab#GenVocabMultilingualProduct');

  @override
  GenVocabMultilingualProduct fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String name = reader.require(
      const IriTerm('https://example.com/vocab#name'),
    );
    final double price = reader.require(
      const IriTerm('https://example.com/vocab#price'),
    );

    return GenVocabMultilingualProduct(id: id, name: name, price: price);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    GenVocabMultilingualProduct resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('https://example.com/vocab#name'),
          resource.name,
        )
        .addValue(
          const IriTerm('https://example.com/vocab#price'),
          resource.price,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(GenVocabMultilingualProduct resource) {
    final id = resource.id;
    return 'https://example.com/products/${id}';
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class GenVocabArticleAuthorIdMapper implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^https://example\.com/authors/(?<authorId>[^/]*)$',
  );

  /// Constructor
  const GenVocabArticleAuthorIdMapper();

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['authorId']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final authorId = iriTermValue.toString();
    return context.createIriTerm('https://example.com/authors/${authorId}');
  }
}

/// Generated mapper for [GenVocabArticle] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `GenVocabArticle`.
class GenVocabArticleMapper implements GlobalResourceMapper<GenVocabArticle> {
  static final RegExp _regex = RegExp(
    r'^https://example\.com/articles/(?<id>[^/]*)$',
  );

  final IriTermMapper<String> _authorIdMapper;

  /// Constructor
  const GenVocabArticleMapper({
    IriTermMapper<String> authorIdMapper =
        const GenVocabArticleAuthorIdMapper(),
  }) : _authorIdMapper = authorIdMapper;

  @override
  IriTerm? get typeIri =>
      const IriTerm('https://example.com/vocab#GenVocabArticle');

  @override
  GenVocabArticle fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String name = reader.require(SchemaCreativeWork.name);
    final String dateCreated = reader.require(SchemaCreativeWork.dateCreated);
    final String authorId = reader.require(
      SchemaCreativeWork.author,
      deserializer: _authorIdMapper,
    );
    final int viewCount = reader.require(
      const IriTerm('https://example.com/vocab#viewCount'),
    );
    final String internalNotes = reader.require(
      const IriTerm('https://example.com/vocab#internalNotes'),
    );

    return GenVocabArticle(
      id: id,
      name: name,
      dateCreated: dateCreated,
      authorId: authorId,
      viewCount: viewCount,
      internalNotes: internalNotes,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    GenVocabArticle resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(SchemaCreativeWork.name, resource.name)
        .addValue(SchemaCreativeWork.dateCreated, resource.dateCreated)
        .addValue(
          SchemaCreativeWork.author,
          resource.authorId,
          serializer: _authorIdMapper,
        )
        .addValue(
          const IriTerm('https://example.com/vocab#viewCount'),
          resource.viewCount,
        )
        .addValue(
          const IriTerm('https://example.com/vocab#internalNotes'),
          resource.internalNotes,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(GenVocabArticle resource) {
    final id = resource.id;
    return 'https://example.com/articles/${id}';
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class GenVocabPropertyTypeOverridePrimaryAuthorIdMapper
    implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^https://example\.com/authors/(?<primaryAuthorId>[^/]*)$',
  );

  /// Constructor
  const GenVocabPropertyTypeOverridePrimaryAuthorIdMapper();

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['primaryAuthorId']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final primaryAuthorId = iriTermValue.toString();
    return context.createIriTerm(
      'https://example.com/authors/${primaryAuthorId}',
    );
  }
}

/// Generated mapper for [GenVocabPropertyTypeOverride] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `GenVocabPropertyTypeOverride`.
class GenVocabPropertyTypeOverrideMapper
    implements GlobalResourceMapper<GenVocabPropertyTypeOverride> {
  static final RegExp _regex = RegExp(
    r'^https://example\.com/publications/(?<id>[^/]*)$',
  );

  final IriTermMapper<String> _primaryAuthorIdMapper;

  /// Constructor
  const GenVocabPropertyTypeOverrideMapper({
    IriTermMapper<String> primaryAuthorIdMapper =
        const GenVocabPropertyTypeOverridePrimaryAuthorIdMapper(),
  }) : _primaryAuthorIdMapper = primaryAuthorIdMapper;

  @override
  IriTerm? get typeIri =>
      const IriTerm('https://example.com/vocab#GenVocabPropertyTypeOverride');

  @override
  GenVocabPropertyTypeOverride fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String title = reader.require(
      const IriTerm('http://purl.org/dc/terms/title'),
    );
    final int wordCount = reader.require(
      const IriTerm('https://example.com/vocab#wordCount'),
    );
    final String primaryAuthorId = reader.require(
      const IriTerm('https://example.com/vocab#primaryAuthor'),
      deserializer: _primaryAuthorIdMapper,
    );

    return GenVocabPropertyTypeOverride(
      id: id,
      title: title,
      wordCount: wordCount,
      primaryAuthorId: primaryAuthorId,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    GenVocabPropertyTypeOverride resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('http://purl.org/dc/terms/title'),
          resource.title,
        )
        .addValue(
          const IriTerm('https://example.com/vocab#wordCount'),
          resource.wordCount,
        )
        .addValue(
          const IriTerm('https://example.com/vocab#primaryAuthor'),
          resource.primaryAuthorId,
          serializer: _primaryAuthorIdMapper,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(GenVocabPropertyTypeOverride resource) {
    final id = resource.id;
    return 'https://example.com/publications/${id}';
  }
}

/// Generated mapper for [GenVocabExcludedFields] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `GenVocabExcludedFields`.
class GenVocabExcludedFieldsMapper
    implements GlobalResourceMapper<GenVocabExcludedFields> {
  static final RegExp _regex = RegExp(
    r'^https://example\.com/documents/(?<id>[^/]*)$',
  );

  /// Constructor
  const GenVocabExcludedFieldsMapper();

  @override
  IriTerm? get typeIri =>
      const IriTerm('https://example.com/vocab#GenVocabExcludedFields');

  @override
  GenVocabExcludedFields fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String title = reader.require(
      const IriTerm('http://purl.org/dc/terms/title'),
    );

    // Get unmapped triples as the last reader operation for lossless mapping
    final RdfGraph unmappedTriples = reader.getUnmapped<RdfGraph>();

    return GenVocabExcludedFields(
      id: id,
      title: title,
      unmappedTriples: unmappedTriples,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    GenVocabExcludedFields resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('http://purl.org/dc/terms/title'),
          resource.title,
        )
        .addUnmapped(resource.unmappedTriples)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(GenVocabExcludedFields resource) {
    final id = resource.id;
    return 'https://example.com/documents/${id}';
  }
}
