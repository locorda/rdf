// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/enum_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'enum_test_models.dart';

/// Generated mapper for [Priority] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type Priority.
class PriorityMapper implements LiteralTermMapper<Priority> {
  final IriTerm? datatype = null;

  const PriorityMapper();

  @override
  Priority fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) => switch (term.value) {
    'low' => Priority.low,
    'medium' => Priority.medium,
    'high' => Priority.high,
    _ => throw DeserializationException(
      'Unknown Priority literal value: ${term.value}',
    ),
  };

  @override
  LiteralTerm toRdfTerm(
    Priority value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    Priority.low => LiteralTerm('low'),
    Priority.medium => LiteralTerm('medium'),
    Priority.high => LiteralTerm('high'),
  };
}

/// Generated mapper for [Status] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type Status.
class StatusMapper implements LiteralTermMapper<Status> {
  final IriTerm? datatype = null;

  const StatusMapper();

  @override
  Status fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) => switch (term.value) {
    'new' => Status.newItem,
    'in-progress' => Status.inProgress,
    'completed' => Status.completed,
    'canceled' => Status.canceled,
    _ => throw DeserializationException(
      'Unknown Status literal value: ${term.value}',
    ),
  };

  @override
  LiteralTerm toRdfTerm(
    Status value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    Status.newItem => LiteralTerm('new'),
    Status.inProgress => LiteralTerm('in-progress'),
    Status.completed => LiteralTerm('completed'),
    Status.canceled => LiteralTerm('canceled'),
  };
}

/// Generated mapper for [DocumentType] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type DocumentType.
class DocumentTypeMapper implements IriTermMapper<DocumentType> {
  /// Constructor
  const DocumentTypeMapper();

  @override
  DocumentType fromRdfTerm(IriTerm term, DeserializationContext context) {
    final enumValue = term.value;

    return switch (enumValue) {
      'https://www.iana.org/assignments/media-types/text/plain' =>
        DocumentType.plainText,
      'https://www.iana.org/assignments/media-types/text/html' =>
        DocumentType.html,
      'https://www.iana.org/assignments/media-types/application/pdf' =>
        DocumentType.pdf,
      _ => throw DeserializationException(
        'Unknown DocumentType IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    DocumentType value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    DocumentType.plainText => context.createIriTerm(
      'https://www.iana.org/assignments/media-types/text/plain',
    ),
    DocumentType.html => context.createIriTerm(
      'https://www.iana.org/assignments/media-types/text/html',
    ),
    DocumentType.pdf => context.createIriTerm(
      'https://www.iana.org/assignments/media-types/application/pdf',
    ),
  };
}

/// Generated mapper for [CategoryType] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type CategoryType.
class CategoryTypeMapper implements IriTermMapper<CategoryType> {
  static final RegExp _regex = RegExp(
    r'^https://example\.org/types/(?<value>[^/]*)$',
  );

  /// Constructor
  const CategoryTypeMapper();

  @override
  CategoryType fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException('Unknown CategoryType IRI: ${term.value}');
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'books' => CategoryType.books,
      'music' => CategoryType.music,
      'electronics' => CategoryType.electronics,
      _ => throw DeserializationException(
        'Unknown CategoryType IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    CategoryType value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    CategoryType.books => context.createIriTerm(_buildIri('books')),
    CategoryType.music => context.createIriTerm(_buildIri('music')),
    CategoryType.electronics => context.createIriTerm(_buildIri('electronics')),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    return 'https://example.org/types/${value}';
  }
}

/// Generated mapper for [FileFormat] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type FileFormat.
class FileFormatMapper implements IriTermMapper<FileFormat> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/formats/(?<value>[^/]*)$',
  );

  final String Function() _baseUriProvider;

  /// Constructor
  const FileFormatMapper({required String Function() baseUriProvider})
    : _baseUriProvider = baseUriProvider;

  @override
  FileFormat fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException('Unknown FileFormat IRI: ${term.value}');
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'text' => FileFormat.text,
      'binary' => FileFormat.binary,
      'xml' => FileFormat.xml,
      _ => throw DeserializationException(
        'Unknown FileFormat IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    FileFormat value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    FileFormat.text => context.createIriTerm(_buildIri('text')),
    FileFormat.binary => context.createIriTerm(_buildIri('binary')),
    FileFormat.xml => context.createIriTerm(_buildIri('xml')),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    final baseUri = _baseUriProvider();
    return '${baseUri}/formats/${value}';
  }
}

/// Generated mapper for [ItemType] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type ItemType.
class ItemTypeMapper implements IriTermMapper<ItemType> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/types/(?<category>[^/]*)/(?<value>[^/]*)$',
  );

  final String Function() _baseUriProvider;
  final String Function() _categoryProvider;

  /// Constructor
  const ItemTypeMapper({
    required String Function() baseUriProvider,
    required String Function() categoryProvider,
  }) : _baseUriProvider = baseUriProvider,
       _categoryProvider = categoryProvider;

  @override
  ItemType fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException('Unknown ItemType IRI: ${term.value}');
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'book' => ItemType.book,
      'magazine' => ItemType.magazine,
      'newspaper' => ItemType.newspaper,
      _ => throw DeserializationException(
        'Unknown ItemType IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    ItemType value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    ItemType.book => context.createIriTerm(_buildIri('book')),
    ItemType.magazine => context.createIriTerm(_buildIri('magazine')),
    ItemType.newspaper => context.createIriTerm(_buildIri('newspaper')),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    final baseUri = _baseUriProvider();
    final category = _categoryProvider();
    return '${baseUri}/types/${category}/${value}';
  }
}
