// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/iri_processor_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations
// ignore_for_file: depend_on_referenced_packages

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'iri_processor_test_models.dart';

/// Generated mapper for [IriWithOnePart] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `IriWithOnePart`.
class IriWithOnePartMapper implements IriTermMapper<IriWithOnePart> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/books/(?<isbn>[^/]*)$',
  );

  /// Constructor
  const IriWithOnePartMapper();

  @override
  IriWithOnePart fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final isbn = iriParts['isbn'];
    if (isbn == null) {
      throw DeserializationException(
        'Missing required IRI part: isbn in IRI ${term.value}',
      );
    }

    return IriWithOnePart(isbn: isbn);
  }

  @override
  IriTerm toRdfTerm(
    IriWithOnePart iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final isbn = iriTermValue.isbn;
    return context.createIriTerm('http://example.org/books/${isbn}');
  }
}

/// Generated mapper for [IriWithOnePartExplicitlyGlobal] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `IriWithOnePartExplicitlyGlobal`.
class IriWithOnePartExplicitlyGlobalMapper
    implements IriTermMapper<IriWithOnePartExplicitlyGlobal> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/books/(?<isbn>[^/]*)$',
  );

  /// Constructor
  const IriWithOnePartExplicitlyGlobalMapper();

  @override
  IriWithOnePartExplicitlyGlobal fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final isbn = iriParts['isbn'];
    if (isbn == null) {
      throw DeserializationException(
        'Missing required IRI part: isbn in IRI ${term.value}',
      );
    }

    return IriWithOnePartExplicitlyGlobal(isbn: isbn);
  }

  @override
  IriTerm toRdfTerm(
    IriWithOnePartExplicitlyGlobal iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final isbn = iriTermValue.isbn;
    return context.createIriTerm('http://example.org/books/${isbn}');
  }
}

/// Generated mapper for [IriWithOnePartNamed] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `IriWithOnePartNamed`.
class IriWithOnePartNamedMapper implements IriTermMapper<IriWithOnePartNamed> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/books/(?<isbn>[^/]*)$',
  );

  /// Constructor
  const IriWithOnePartNamedMapper();

  @override
  IriWithOnePartNamed fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final value = iriParts['isbn'];
    if (value == null) {
      throw DeserializationException(
        'Missing required IRI part: isbn in IRI ${term.value}',
      );
    }

    return IriWithOnePartNamed(value: value);
  }

  @override
  IriTerm toRdfTerm(
    IriWithOnePartNamed iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final value = iriTermValue.value;
    return context.createIriTerm('http://example.org/books/${value}');
  }
}

/// Generated mapper for [IriWithTwoParts] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `IriWithTwoParts`.
class IriWithTwoPartsMapper implements IriTermMapper<IriWithTwoParts> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/(?<type>[^/]*)/(?<value>[^/]*)$',
  );

  /// Constructor
  const IriWithTwoPartsMapper();

  @override
  IriWithTwoParts fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final value = iriParts['value'];
    if (value == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }
    final type = iriParts['type'];
    if (type == null) {
      throw DeserializationException(
        'Missing required IRI part: type in IRI ${term.value}',
      );
    }

    return IriWithTwoParts(value: value, type: type);
  }

  @override
  IriTerm toRdfTerm(
    IriWithTwoParts iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final value = iriTermValue.value;
    final type = iriTermValue.type;
    return context.createIriTerm('http://example.org/${type}/${value}');
  }
}

/// Generated mapper for [IriWithBaseUriAndTwoParts] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `IriWithBaseUriAndTwoParts`.
class IriWithBaseUriAndTwoPartsMapper
    implements IriTermMapper<IriWithBaseUriAndTwoParts> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/(?<type>[^/]*)/(?<value>[^/]*)$',
  );

  final String Function() _baseUriProvider;

  /// Constructor
  const IriWithBaseUriAndTwoPartsMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  IriWithBaseUriAndTwoParts fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final value = iriParts['value'];
    if (value == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }
    final otherPart = iriParts['type'];
    if (otherPart == null) {
      throw DeserializationException(
        'Missing required IRI part: type in IRI ${term.value}',
      );
    }

    return IriWithBaseUriAndTwoParts(value: value, otherPart: otherPart);
  }

  @override
  IriTerm toRdfTerm(
    IriWithBaseUriAndTwoParts iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final value = iriTermValue.value;
    final otherPart = iriTermValue.otherPart;
    final baseUri = _baseUriProvider();
    return context.createIriTerm('${baseUri}/${otherPart}/${value}');
  }
}

/// Generated mapper for [IriWithBaseUri] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `IriWithBaseUri`.
class IriWithBaseUriMapper implements IriTermMapper<IriWithBaseUri> {
  static final RegExp _regex = RegExp(r'^(?<baseUri>.*)/books/(?<isbn>[^/]*)$');

  final String Function() _baseUriProvider;

  /// Constructor
  const IriWithBaseUriMapper({required String Function() baseUriProvider})
    : _baseUriProvider = baseUriProvider;

  @override
  IriWithBaseUri fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final isbn = iriParts['isbn'];
    if (isbn == null) {
      throw DeserializationException(
        'Missing required IRI part: isbn in IRI ${term.value}',
      );
    }

    return IriWithBaseUri(isbn: isbn);
  }

  @override
  IriTerm toRdfTerm(
    IriWithBaseUri iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final isbn = iriTermValue.isbn;
    final baseUri = _baseUriProvider();
    return context.createIriTerm('${baseUri}/books/${isbn}');
  }
}

/// Generated mapper for [IriWithBaseUriNoGlobal] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `IriWithBaseUriNoGlobal`.
class IriWithBaseUriNoGlobalMapper
    implements IriTermMapper<IriWithBaseUriNoGlobal> {
  static final RegExp _regex = RegExp(r'^(?<baseUri>.*)/books/(?<isbn>[^/]*)$');

  final String Function() _baseUriProvider;

  /// Constructor
  const IriWithBaseUriNoGlobalMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  IriWithBaseUriNoGlobal fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final isbn = iriParts['isbn'];
    if (isbn == null) {
      throw DeserializationException(
        'Missing required IRI part: isbn in IRI ${term.value}',
      );
    }

    return IriWithBaseUriNoGlobal(isbn: isbn);
  }

  @override
  IriTerm toRdfTerm(
    IriWithBaseUriNoGlobal iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final isbn = iriTermValue.isbn;
    final baseUri = _baseUriProvider();
    return context.createIriTerm('${baseUri}/books/${isbn}');
  }
}

/// Generated mapper for [IriWithNonConstructorFields] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `IriWithNonConstructorFields`.
class IriWithNonConstructorFieldsMapper
    implements IriTermMapper<IriWithNonConstructorFields> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/items/(?<id>[^/]*)$',
  );

  /// Constructor
  const IriWithNonConstructorFieldsMapper();

  @override
  IriWithNonConstructorFields fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${term.value}',
      );
    }

    final retval = IriWithNonConstructorFields();
    retval.id = id;
    return retval;
  }

  @override
  IriTerm toRdfTerm(
    IriWithNonConstructorFields iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final id = iriTermValue.id;
    return context.createIriTerm('http://example.org/items/${id}');
  }
}

/// Generated mapper for [IriWithNonConstructorFieldsAndBaseUriNonGlobal] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `IriWithNonConstructorFieldsAndBaseUriNonGlobal`.
class IriWithNonConstructorFieldsAndBaseUriNonGlobalMapper
    implements IriTermMapper<IriWithNonConstructorFieldsAndBaseUriNonGlobal> {
  static final RegExp _regex = RegExp(r'^(?<myBaseUri>.*)/items/(?<id>[^/]*)$');

  final String Function() _myBaseUriProvider;

  /// Constructor
  const IriWithNonConstructorFieldsAndBaseUriNonGlobalMapper({
    required String Function() myBaseUriProvider,
  }) : _myBaseUriProvider = myBaseUriProvider;

  @override
  IriWithNonConstructorFieldsAndBaseUriNonGlobal fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${term.value}',
      );
    }

    final retval = IriWithNonConstructorFieldsAndBaseUriNonGlobal();
    retval.id = id;
    return retval;
  }

  @override
  IriTerm toRdfTerm(
    IriWithNonConstructorFieldsAndBaseUriNonGlobal iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final id = iriTermValue.id;
    final myBaseUri = _myBaseUriProvider();
    return context.createIriTerm('${myBaseUri}/items/${id}');
  }
}

/// Generated mapper for [IriWithMixedFields] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `IriWithMixedFields`.
class IriWithMixedFieldsMapper implements IriTermMapper<IriWithMixedFields> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/products/(?<brand>[^/]*)/(?<category>[^/]*)/(?<id>[^/]*)$',
  );

  /// Constructor
  const IriWithMixedFieldsMapper();

  @override
  IriWithMixedFields fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final brand = iriParts['brand'];
    if (brand == null) {
      throw DeserializationException(
        'Missing required IRI part: brand in IRI ${term.value}',
      );
    }
    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${term.value}',
      );
    }
    final productCategory = iriParts['category'];
    if (productCategory == null) {
      throw DeserializationException(
        'Missing required IRI part: category in IRI ${term.value}',
      );
    }

    final retval = IriWithMixedFields(brand: brand, id: id);
    retval.productCategory = productCategory;
    return retval;
  }

  @override
  IriTerm toRdfTerm(
    IriWithMixedFields iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final brand = iriTermValue.brand;
    final productCategory = iriTermValue.productCategory;
    final id = iriTermValue.id;
    return context.createIriTerm(
      'http://example.org/products/${brand}/${productCategory}/${id}',
    );
  }
}
