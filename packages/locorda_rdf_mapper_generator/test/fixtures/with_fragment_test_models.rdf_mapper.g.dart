// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/with_fragment_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'with_fragment_test_models.dart';

/// Generated mapper for [SectionReference] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `SectionReference`.
class SectionReferenceMapper implements IriTermMapper<SectionReference> {
  static final RegExp _regex = RegExp(
    r'^(?<documentIri>.*)#section-(?<sectionId>[^/]*)$',
  );

  final String Function() _documentIriProvider;

  /// Constructor
  const SectionReferenceMapper({required String Function() documentIriProvider})
      : _documentIriProvider = documentIriProvider;

  @override
  SectionReference fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final sectionId = iriParts['sectionId'];
    if (sectionId == null) {
      throw DeserializationException(
        'Missing required IRI part: sectionId in IRI ${term.value}',
      );
    }

    return SectionReference(sectionId);
  }

  @override
  IriTerm toRdfTerm(
    SectionReference iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final sectionId = iriTermValue.sectionId;
    final documentIri = _documentIriProvider();
    var interpolatedTemplate = '${documentIri}';
    if (interpolatedTemplate.contains('#')) {
      interpolatedTemplate = interpolatedTemplate.substring(
        0,
        interpolatedTemplate.indexOf('#'),
      );
    }
    return context.createIriTerm('$interpolatedTemplate#section-${sectionId}');
  }
}

/// Generated mapper for [Document] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Document`.
class DocumentMapper implements GlobalResourceMapper<Document> {
  static final RegExp _regex = RegExp(
    r'^tag:example\.org,2025:document-(?<id>[^/]*)$',
  );

  /// Constructor
  const DocumentMapper();

  @override
  IriTerm? get typeIri => const IriTerm('http://example.org/Document');

  @override
  Document fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final SectionReference section = reader.require(
      const IriTerm('http://example.org/currentSection'),
      deserializer: SectionReferenceMapper(
        documentIriProvider: () =>
            throw Exception('Must not call provider for deserialization'),
      ),
    );

    return Document(id, section);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Document resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('http://example.org/currentSection'),
          resource.section,
          serializer: SectionReferenceMapper(
            documentIriProvider: () => subject.value,
          ),
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Document resource) {
    final id = resource.id;
    return 'tag:example.org,2025:document-${id}';
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class ArticleRefIdMapper implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^(?<articleIri>.*)#section-(?<refId>[^/]*)$',
  );

  final String Function() _articleIriProvider;

  /// Constructor
  const ArticleRefIdMapper({required String Function() articleIriProvider})
      : _articleIriProvider = articleIriProvider;

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['refId']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final refId = iriTermValue.toString();
    final articleIri = _articleIriProvider();
    var interpolatedTemplate = '${articleIri}';
    if (interpolatedTemplate.contains('#')) {
      interpolatedTemplate = interpolatedTemplate.substring(
        0,
        interpolatedTemplate.indexOf('#'),
      );
    }
    return context.createIriTerm('$interpolatedTemplate#section-${refId}');
  }
}

/// Generated mapper for [Article] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Article`.
class ArticleMapper implements GlobalResourceMapper<Article> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/articles/(?<articleId>[^/]*)$',
  );

  /// Constructor
  const ArticleMapper();

  @override
  IriTerm? get typeIri => const IriTerm('http://example.org/Article');

  @override
  Article fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final articleId = iriParts['articleId'];
    if (articleId == null) {
      throw DeserializationException(
        'Missing required IRI part: articleId in IRI ${subject.value}',
      );
    }
    final String refId = reader.require(
      const IriTerm('http://example.org/relatedSection'),
      deserializer: ArticleRefIdMapper(
        articleIriProvider: () =>
            throw Exception('Must not call provider for deserialization'),
      ),
    );

    return Article(articleId, refId);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Article resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('http://example.org/relatedSection'),
          resource.refId,
          serializer: ArticleRefIdMapper(
            articleIriProvider: () => subject.value,
          ),
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Article resource) {
    final articleId = resource.articleId;
    return 'http://example.org/articles/${articleId}';
  }
}

/// Generated mapper for [Page] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Page`.
class PageMapper implements GlobalResourceMapper<Page> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/pages/overview#(?<pageId>[^/]*)$',
  );

  final String Function() _baseUriProvider;

  /// Constructor
  const PageMapper({required String Function() baseUriProvider})
      : _baseUriProvider = baseUriProvider;

  @override
  IriTerm? get typeIri => const IriTerm('http://example.org/Page');

  @override
  Page fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final pageId = iriParts['pageId'];
    if (pageId == null) {
      throw DeserializationException(
        'Missing required IRI part: pageId in IRI ${subject.value}',
      );
    }
    final String title = reader.require(
      const IriTerm('http://example.org/title'),
    );

    return Page(pageId, title);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Page resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(const IriTerm('http://example.org/title'), resource.title)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Page resource) {
    final pageId = resource.pageId;
    final baseUri = _baseUriProvider();
    var interpolatedTemplate = '${baseUri}/pages/overview#intro';
    if (interpolatedTemplate.contains('#')) {
      interpolatedTemplate = interpolatedTemplate.substring(
        0,
        interpolatedTemplate.indexOf('#'),
      );
    }
    return '$interpolatedTemplate#${pageId}';
  }
}
