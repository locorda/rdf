// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/comprehensive_collection_tests.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'comprehensive_collection_tests.dart';
import 'package:locorda_rdf_terms_schema/schema.dart';
import 'package:locorda_rdf_terms_core/xsd.dart';

/// Generated mapper for [RegistryCollectionTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `RegistryCollectionTests`.
class RegistryCollectionTestsMapper
    implements LocalResourceMapper<RegistryCollectionTests> {
  /// Constructor
  const RegistryCollectionTestsMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  RegistryCollectionTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> registryManagedCollection = reader.require(
      TestVocab.registryCollection,
    );

    return RegistryCollectionTests(
      registryManagedCollection: registryManagedCollection,
    );
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    RegistryCollectionTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          TestVocab.registryCollection,
          resource.registryManagedCollection,
        )
        .build();
  }
}

/// Generated mapper for [NamedMapperCollectionTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `NamedMapperCollectionTests`.
class NamedMapperCollectionTestsMapper
    implements LocalResourceMapper<NamedMapperCollectionTests> {
  final Mapper<List<String>> _namedManagedCollectionMapper;

  /// Constructor
  const NamedMapperCollectionTestsMapper({
    required Mapper<List<String>> customCollectionMapper,
  }) : _namedManagedCollectionMapper = customCollectionMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  NamedMapperCollectionTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> namedManagedCollection = reader.require(
      TestVocab.namedMapperCollection,
      deserializer: _namedManagedCollectionMapper,
    );

    return NamedMapperCollectionTests(
      namedManagedCollection: namedManagedCollection,
    );
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    NamedMapperCollectionTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          TestVocab.namedMapperCollection,
          resource.namedManagedCollection,
          serializer: _namedManagedCollectionMapper,
        )
        .build();
  }
}

/// Generated mapper for [SelfContainedMapperTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `SelfContainedMapperTests`.
class SelfContainedMapperTestsMapper
    implements LocalResourceMapper<SelfContainedMapperTests> {
  final Mapper<List<String>> _selfContainedCollectionMapper;

  /// Constructor
  const SelfContainedMapperTestsMapper({
    Mapper<List<String>> selfContainedCollectionMapper =
        const StringListMapper(),
  }) : _selfContainedCollectionMapper = selfContainedCollectionMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  SelfContainedMapperTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> selfContainedCollection = reader.require(
      TestVocab.selfContainedCollection,
      deserializer: _selfContainedCollectionMapper,
    );

    return SelfContainedMapperTests(
      selfContainedCollection: selfContainedCollection,
    );
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    SelfContainedMapperTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          TestVocab.selfContainedCollection,
          resource.selfContainedCollection,
          serializer: _selfContainedCollectionMapper,
        )
        .build();
  }
}

/// Generated mapper for [InstanceManagedCollectionTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `InstanceManagedCollectionTests`.
class InstanceManagedCollectionTestsMapper
    implements LocalResourceMapper<InstanceManagedCollectionTests> {
  final Mapper<List<String>> _instanceManagedCollectionMapper;

  /// Constructor
  const InstanceManagedCollectionTestsMapper({
    Mapper<List<String>> instanceManagedCollectionMapper =
        const ConfigurableCollectionMapper(prefix: 'LIST:', separator: '|'),
  }) : _instanceManagedCollectionMapper = instanceManagedCollectionMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  InstanceManagedCollectionTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> instanceManagedCollection = reader.require(
      TestVocab.instanceManagedCollection,
      deserializer: _instanceManagedCollectionMapper,
    );

    return InstanceManagedCollectionTests(
      instanceManagedCollection: instanceManagedCollection,
    );
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    InstanceManagedCollectionTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          TestVocab.instanceManagedCollection,
          resource.instanceManagedCollection,
          serializer: _instanceManagedCollectionMapper,
        )
        .build();
  }
}

/// Generated mapper for [SetAndIterableCollectionTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `SetAndIterableCollectionTests`.
class SetAndIterableCollectionTestsMapper
    implements LocalResourceMapper<SetAndIterableCollectionTests> {
  /// Constructor
  const SetAndIterableCollectionTestsMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  SetAndIterableCollectionTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> bagCollection = reader
        .requireCollection<List<String>, String>(
          TestVocab.bagCollection,
          RdfBagMapper.new,
        );
    final List<String> orderedCollection = reader
        .requireCollection<List<String>, String>(
          TestVocab.orderedCollection,
          RdfListMapper.new,
        );
    final Iterable<String> defaultIterable = reader
        .requireCollection<Iterable<String>, String>(
          TestVocab.defaultIterable,
          UnorderedItemsMapper.new,
        );
    final List<String> sequenceIterable = reader
        .requireCollection<List<String>, String>(
          TestVocab.sequenceIterable,
          RdfSeqMapper.new,
        );

    return SetAndIterableCollectionTests(
      bagCollection: bagCollection,
      orderedCollection: orderedCollection,
      defaultIterable: defaultIterable,
      sequenceIterable: sequenceIterable,
    );
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    SetAndIterableCollectionTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addCollection<List<String>, String>(
          TestVocab.bagCollection,
          resource.bagCollection,
          RdfBagMapper.new,
        )
        .addCollection<List<String>, String>(
          TestVocab.orderedCollection,
          resource.orderedCollection,
          RdfListMapper.new,
        )
        .addCollection<Iterable<String>, String>(
          TestVocab.defaultIterable,
          resource.defaultIterable,
          UnorderedItemsMapper.new,
        )
        .addCollection<List<String>, String>(
          TestVocab.sequenceIterable,
          resource.sequenceIterable,
          RdfSeqMapper.new,
        )
        .build();
  }
}

/// Generated mapper for [ComplexItem] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `ComplexItem`.
class ComplexItemMapper implements LocalResourceMapper<ComplexItem> {
  /// Constructor
  const ComplexItemMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  ComplexItem fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String name = reader.require(SchemaEvent.name);
    final int id = reader.require(SchemaEvent.identifier);

    return ComplexItem(name: name, id: id);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    ComplexItem resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaEvent.name, resource.name)
        .addValue(SchemaEvent.identifier, resource.id)
        .build();
  }
}

/// Generated mapper for [ItemTypeParameterTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `ItemTypeParameterTests`.
class ItemTypeParameterTestsMapper
    implements LocalResourceMapper<ItemTypeParameterTests> {
  final LocalResourceMapper<ComplexItem> _complexCollectionMapper;

  /// Constructor
  const ItemTypeParameterTestsMapper({
    required LocalResourceMapper<ComplexItem> complexItemMapperLocal,
  }) : _complexCollectionMapper = complexItemMapperLocal;

  @override
  IriTerm? get typeIri => null;

  @override
  ItemTypeParameterTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final CustomCollection complexCollection = reader
        .requireCollection<CustomCollection, ComplexItem>(
          TestVocab.complexCollection,
          CustomCollectionMapper.new,
          itemDeserializer: _complexCollectionMapper,
        );

    return ItemTypeParameterTests(complexCollection: complexCollection);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    ItemTypeParameterTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addCollection<CustomCollection, ComplexItem>(
          TestVocab.complexCollection,
          resource.complexCollection,
          CustomCollectionMapper.new,
          itemSerializer: _complexCollectionMapper,
        )
        .build();
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class CombinedItemMappingTestsIriItemsListMapper
    implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/item/(?<iriItemsList>[^/]*)$',
  );

  final String Function() _baseUriProvider;

  /// Constructor
  const CombinedItemMappingTestsIriItemsListMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['iriItemsList']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final iriItemsList = iriTermValue.toString();
    final baseUri = _baseUriProvider();
    return context.createIriTerm('${baseUri}/item/${iriItemsList}');
  }
}

/// Generated mapper for [CombinedItemMappingTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `CombinedItemMappingTests`.
class CombinedItemMappingTestsMapper
    implements LocalResourceMapper<CombinedItemMappingTests> {
  final String Function() _baseUriProvider;
  late final IriTermMapper<String> _iriItemsListMapper;
  final LiteralTermMapper<String> _languageTaggedBagMapper;
  final GlobalResourceMapper<ComplexItem> _resourceItemsSeqMapper;

  /// Constructor
  CombinedItemMappingTestsMapper({
    required String Function() baseUriProvider,
    required GlobalResourceMapper<ComplexItem> complexItemMapperGlobal,
    LiteralTermMapper<String> languageTaggedBagMapper =
        const LanguageOverrideMapper<String>('en'),
  }) : _baseUriProvider = baseUriProvider,
       _resourceItemsSeqMapper = complexItemMapperGlobal,
       _languageTaggedBagMapper = languageTaggedBagMapper {
    _iriItemsListMapper = CombinedItemMappingTestsIriItemsListMapper(
      baseUriProvider: baseUriProvider,
    );
  }

  @override
  IriTerm? get typeIri => null;

  @override
  CombinedItemMappingTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> iriItemsList = reader
        .requireCollection<List<String>, String>(
          TestVocab.iriItemsList,
          RdfListMapper.new,
          itemDeserializer: _iriItemsListMapper,
        );
    final List<ComplexItem> resourceItemsSeq = reader
        .requireCollection<List<ComplexItem>, ComplexItem>(
          TestVocab.resourceItemsSeq,
          RdfSeqMapper.new,
          itemDeserializer: _resourceItemsSeqMapper,
        );
    final List<String> languageTaggedBag = reader
        .requireCollection<List<String>, String>(
          TestVocab.languageTaggedBag,
          RdfBagMapper.new,
          itemDeserializer: _languageTaggedBagMapper,
        );

    return CombinedItemMappingTests(
      iriItemsList: iriItemsList,
      resourceItemsSeq: resourceItemsSeq,
      languageTaggedBag: languageTaggedBag,
    );
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    CombinedItemMappingTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addCollection<List<String>, String>(
          TestVocab.iriItemsList,
          resource.iriItemsList,
          RdfListMapper.new,
          itemSerializer: _iriItemsListMapper,
        )
        .addCollection<List<ComplexItem>, ComplexItem>(
          TestVocab.resourceItemsSeq,
          resource.resourceItemsSeq,
          RdfSeqMapper.new,
          itemSerializer: _resourceItemsSeqMapper,
        )
        .addCollection<List<String>, String>(
          TestVocab.languageTaggedBag,
          resource.languageTaggedBag,
          RdfBagMapper.new,
          itemSerializer: _languageTaggedBagMapper,
        )
        .build();
  }
}

/// Generated mapper for [EdgeCaseTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `EdgeCaseTests`.
class EdgeCaseTestsMapper implements LocalResourceMapper<EdgeCaseTests> {
  /// Constructor
  const EdgeCaseTestsMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  EdgeCaseTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> emptyList = reader
        .requireCollection<List<String>, String>(
          TestVocab.emptyList,
          RdfListMapper.new,
        );
    final List<String> nullableList =
        reader.optionalCollection<List<String>, String>(
          TestVocab.nullableList,
          RdfSeqMapper.new,
        ) ??
        [];

    return EdgeCaseTests(emptyList: emptyList, nullableList: nullableList);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    EdgeCaseTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addCollection<List<String>, String>(
          TestVocab.emptyList,
          resource.emptyList,
          RdfListMapper.new,
        )
        .when(
          resource.nullableList != [],
          (b) => b.addCollection<List<String>, String>(
            TestVocab.nullableList,
            resource.nullableList,
            RdfSeqMapper.new,
          ),
        )
        .build();
  }
}

/// Generated mapper for [PerformanceTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `PerformanceTests`.
class PerformanceTestsMapper implements LocalResourceMapper<PerformanceTests> {
  /// Constructor
  const PerformanceTestsMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  PerformanceTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> performanceList = reader
        .requireCollection<List<String>, String>(
          TestVocab.performanceList,
          RdfListMapper.new,
        );

    return PerformanceTests(performanceList: performanceList);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    PerformanceTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addCollection<List<String>, String>(
          TestVocab.performanceList,
          resource.performanceList,
          RdfListMapper.new,
        )
        .build();
  }
}

/// Generated mapper for [MapCollectionTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `MapCollectionTests`.
class MapCollectionTestsMapper
    implements LocalResourceMapper<MapCollectionTests> {
  final Mapper<Map<String, String>> _customMapMapper;

  /// Constructor
  const MapCollectionTestsMapper({
    Mapper<Map<String, String>> customMapMapper = const CustomMapMapper(),
  }) : _customMapMapper = customMapMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  MapCollectionTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Map<String, String> defaultMap = reader.getMap<String, String>(
      TestVocab.defaultMap,
    );
    final Map<String, String> customMap = reader.require(
      TestVocab.customMap,
      deserializer: _customMapMapper,
    );

    return MapCollectionTests(defaultMap: defaultMap, customMap: customMap);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    MapCollectionTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addMap<String, String>(TestVocab.defaultMap, resource.defaultMap)
        .addValue(
          TestVocab.customMap,
          resource.customMap,
          serializer: _customMapMapper,
        )
        .build();
  }
}

/// Generated mapper for [DefaultSerializationTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `DefaultSerializationTests`.
class DefaultSerializationTestsMapper
    implements LocalResourceMapper<DefaultSerializationTests> {
  /// Constructor
  const DefaultSerializationTestsMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  DefaultSerializationTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> defaultHandledList =
        reader.optionalCollection<List<String>, String>(
          TestVocab.defaultHandledList,
          RdfListMapper.new,
        ) ??
        [];

    return DefaultSerializationTests(defaultHandledList: defaultHandledList);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    DefaultSerializationTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addCollection<List<String>, String>(
          TestVocab.defaultHandledList,
          resource.defaultHandledList,
          RdfListMapper.new,
        )
        .build();
  }
}

/// Generated mapper for [NestedCollectionTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `NestedCollectionTests`.
class NestedCollectionTestsMapper
    implements LocalResourceMapper<NestedCollectionTests> {
  /// Constructor
  const NestedCollectionTestsMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  NestedCollectionTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<List<String>> nestedCollections = reader
        .requireCollection<List<List<String>>, List<String>>(
          TestVocab.nestedCollections,
          RdfListMapper.new,
        );

    return NestedCollectionTests(nestedCollections: nestedCollections);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    NestedCollectionTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addCollection<List<List<String>>, List<String>>(
          TestVocab.nestedCollections,
          resource.nestedCollections,
          RdfListMapper.new,
        )
        .build();
  }
}

/// Generated mapper for [MixedTypeTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `MixedTypeTests`.
class MixedTypeTestsMapper implements LocalResourceMapper<MixedTypeTests> {
  final LiteralTermMapper<dynamic> _mixedTypeListMapper;

  /// Constructor
  const MixedTypeTestsMapper({
    LiteralTermMapper<dynamic> mixedTypeListMapper =
        const DatatypeOverrideMapper<dynamic>(Xsd.string),
  }) : _mixedTypeListMapper = mixedTypeListMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  MixedTypeTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<dynamic> mixedTypeList = reader
        .requireCollection<List<dynamic>, dynamic>(
          TestVocab.mixedTypeList,
          RdfSeqMapper.new,
          itemDeserializer: _mixedTypeListMapper,
        );

    return MixedTypeTests(mixedTypeList: mixedTypeList);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    MixedTypeTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addCollection<List<dynamic>, dynamic>(
          TestVocab.mixedTypeList,
          resource.mixedTypeList,
          RdfSeqMapper.new,
          itemSerializer: _mixedTypeListMapper,
        )
        .build();
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class ContextProviderTestsContextManagedItemsMapper
    implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/item/(?<contextManagedItems>[^/]*)$',
  );

  final String Function() _baseUriProvider;

  /// Constructor
  const ContextProviderTestsContextManagedItemsMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['contextManagedItems']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final contextManagedItems = iriTermValue.toString();
    final baseUri = _baseUriProvider();
    return context.createIriTerm('${baseUri}/item/${contextManagedItems}');
  }
}

/// Generated mapper for [ContextProviderTests] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `ContextProviderTests`.
class ContextProviderTestsMapper
    implements LocalResourceMapper<ContextProviderTests> {
  /// Constructor
  const ContextProviderTestsMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  ContextProviderTests fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> contextManagedItems = reader
        .requireCollection<List<String>, String>(
          TestVocab.iriItemsList,
          RdfBagMapper.new,
          itemDeserializer: ContextProviderTestsContextManagedItemsMapper(
            baseUriProvider: () =>
                throw Exception('Must not call provider for deserialization'),
          ),
        );

    return ContextProviderTests(contextManagedItems: contextManagedItems);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    ContextProviderTests resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addCollection<List<String>, String>(
          TestVocab.iriItemsList,
          resource.contextManagedItems,
          RdfBagMapper.new,
          itemSerializer: ContextProviderTestsContextManagedItemsMapper(
            baseUriProvider: () => resource.serviceUrl,
          ),
        )
        .build();
  }
}
