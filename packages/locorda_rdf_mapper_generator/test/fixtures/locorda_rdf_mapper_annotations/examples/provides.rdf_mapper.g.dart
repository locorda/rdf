// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/locorda_rdf_mapper_annotations/examples/provides.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'provides.dart';

/// Generated mapper for [Child] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Child`.
class ChildMapper implements GlobalResourceMapper<Child> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/(?<parentId>[^/]*)/child/(?<id>[^/]*)\.ttl$',
  );

  final String Function() _baseUriProvider;
  final String Function() _parentIdProvider;

  /// Constructor
  const ChildMapper({
    required String Function() baseUriProvider,
    required String Function() parentIdProvider,
  })  : _baseUriProvider = baseUriProvider,
        _parentIdProvider = parentIdProvider;

  @override
  IriTerm? get typeIri => ExampleVocab.Child;

  @override
  Child fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String name = reader.require(ExampleVocab.childName);

    final retval = Child();
    retval.id = id;
    retval.name = name;
    return retval;
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Child resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(ExampleVocab.childName, resource.name)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Child resource) {
    final id = resource.id;
    final baseUri = _baseUriProvider();
    final parentId = _parentIdProvider();
    return '${baseUri}/${parentId}/child/${id}.ttl';
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class ParentSiblingIdMapper implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/(?<parentId>[^/]*)/sibling/(?<siblingId>[^/]*)\.ttl$',
  );

  final String Function() _baseUriProvider;
  final String Function() _parentIdProvider;

  /// Constructor
  const ParentSiblingIdMapper({
    required String Function() baseUriProvider,
    required String Function() parentIdProvider,
  })  : _baseUriProvider = baseUriProvider,
        _parentIdProvider = parentIdProvider;

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['siblingId']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final siblingId = iriTermValue.toString();
    final baseUri = _baseUriProvider();
    final parentId = _parentIdProvider();
    return context.createIriTerm(
      '${baseUri}/${parentId}/sibling/${siblingId}.ttl',
    );
  }
}

/// Generated mapper for [Parent] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Parent`.
class ParentMapper implements GlobalResourceMapper<Parent> {
  static final RegExp _regex = RegExp(r'^(?<baseUri>.*)/(?<id>[^/]*)\.ttl$');

  final String Function() _baseUriProvider;

  /// Constructor
  const ParentMapper({required String Function() baseUriProvider})
      : _baseUriProvider = baseUriProvider;

  @override
  IriTerm? get typeIri => ExampleVocab.Parent;

  @override
  Parent fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final Child child = reader.require(
      ExampleVocab.child,
      deserializer: ChildMapper(
        baseUriProvider: _baseUriProvider,
        parentIdProvider: () =>
            throw Exception('Must not call provider for deserialization'),
      ),
    );
    final String siblingId = reader.require(
      ExampleVocab.sibling,
      deserializer: ParentSiblingIdMapper(
        baseUriProvider: _baseUriProvider,
        parentIdProvider: () =>
            throw Exception('Must not call provider for deserialization'),
      ),
    );

    final retval = Parent();
    retval.id = id;
    retval.child = child;
    retval.siblingId = siblingId;
    return retval;
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Parent resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(
          ExampleVocab.child,
          resource.child,
          serializer: ChildMapper(
            baseUriProvider: _baseUriProvider,
            parentIdProvider: () => resource.id,
          ),
        )
        .addValue(
          ExampleVocab.sibling,
          resource.siblingId,
          serializer: ParentSiblingIdMapper(
            baseUriProvider: _baseUriProvider,
            parentIdProvider: () => resource.id,
          ),
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Parent resource) {
    final id = resource.id;
    final baseUri = _baseUriProvider();
    return '${baseUri}/${id}.ttl';
  }
}
