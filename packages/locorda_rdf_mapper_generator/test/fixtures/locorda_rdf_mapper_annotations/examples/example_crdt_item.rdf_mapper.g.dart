// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/locorda_rdf_mapper_annotations/examples/example_crdt_item.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'example_crdt_item.dart';
import 'package:locorda_rdf_terms_common/dcterms.dart';

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class VectorClockEntryClientIdMapper implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^(?<storageRoot>.*)/solidtask/appinstance/(?<clientId>[^/]*)\.ttl$',
  );

  final String Function() _storageRootProvider;

  /// Constructor
  const VectorClockEntryClientIdMapper({
    required String Function() storageRootProvider,
  }) : _storageRootProvider = storageRootProvider;

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['clientId']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final clientId = iriTermValue.toString();
    final storageRoot = _storageRootProvider();
    return context.createIriTerm(
      '${storageRoot}/solidtask/appinstance/${clientId}.ttl',
    );
  }
}

/// Generated mapper for [VectorClockEntry] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `VectorClockEntry`.
class VectorClockEntryMapper implements GlobalResourceMapper<VectorClockEntry> {
  late final IriTermMapper<String> _clientIdMapper;
  final String Function() _storageRootProvider;
  final String Function() _taskIdProvider;

  /// Constructor
  VectorClockEntryMapper({
    required String Function() storageRootProvider,
    required String Function() taskIdProvider,
  })  : _storageRootProvider = storageRootProvider,
        _taskIdProvider = taskIdProvider {
    _clientIdMapper = VectorClockEntryClientIdMapper(
      storageRootProvider: storageRootProvider,
    );
  }

  @override
  IriTerm? get typeIri => SolidTaskVectorClockEntry.classIri;

  @override
  VectorClockEntry fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String clientId = reader.require(
      SolidTaskVectorClockEntry.clientId,
      deserializer: _clientIdMapper,
    );
    final int clockValue = reader.require(SolidTaskVectorClockEntry.clockValue);

    return VectorClockEntry(clientId, clockValue);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    VectorClockEntry resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(
          SolidTaskVectorClockEntry.clientId,
          resource.clientId,
          serializer: _clientIdMapper,
        )
        .addValue(SolidTaskVectorClockEntry.clockValue, resource.clockValue)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(VectorClockEntry resource) {
    final clientId = resource.clientId;
    final storageRoot = _storageRootProvider();
    final taskId = _taskIdProvider();
    return '${storageRoot}/solidtask/task/${taskId}.ttl#vectorclock-${clientId}';
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class ItemLastModifiedByMapper implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^(?<storageRoot>.*)/solidtask/appinstance/(?<lastModifiedBy>[^/]*)\.ttl$',
  );

  final String Function() _storageRootProvider;

  /// Constructor
  const ItemLastModifiedByMapper({
    required String Function() storageRootProvider,
  }) : _storageRootProvider = storageRootProvider;

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['lastModifiedBy']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final lastModifiedBy = iriTermValue.toString();
    final storageRoot = _storageRootProvider();
    return context.createIriTerm(
      '${storageRoot}/solidtask/appinstance/${lastModifiedBy}.ttl',
    );
  }
}

/// Generated mapper for [Item] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Item`.
class ItemMapper implements GlobalResourceMapper<Item> {
  static final RegExp _regex = RegExp(
    r'^(?<storageRoot>.*)/solidtask/task/(?<id>[^/]*)\.ttl$',
  );

  late final IriTermMapper<String> _lastModifiedByMapper;
  final String Function() _storageRootProvider;

  /// Constructor
  ItemMapper({required String Function() storageRootProvider})
      : _storageRootProvider = storageRootProvider {
    _lastModifiedByMapper = ItemLastModifiedByMapper(
      storageRootProvider: storageRootProvider,
    );
  }

  @override
  IriTerm? get typeIri => SolidTaskTask.classIri;

  @override
  Item fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final String text = reader.require(SolidTaskTask.text);
    final String lastModifiedBy = reader.require(
      Dcterms.creator,
      deserializer: _lastModifiedByMapper,
    );
    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final DateTime createdAt = reader.require(Dcterms.created);
    final Map<String, int> vectorClock =
        reader.collect<VectorClockEntry, Map<String, int>>(
      SolidTaskTask.vectorClock,
      (it) => {for (var vc in it) vc.clientId: vc.clockValue},
      deserializer: VectorClockEntryMapper(
        storageRootProvider: _storageRootProvider,
        taskIdProvider: () =>
            throw Exception('Must not call provider for deserialization'),
      ),
    );
    final bool isDeleted = reader.require(SolidTaskTask.isDeleted);

    final retval = Item(text: text, lastModifiedBy: lastModifiedBy);
    retval.id = id;
    retval.createdAt = createdAt;
    retval.vectorClock = vectorClock;
    retval.isDeleted = isDeleted;
    return retval;
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Item resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(SolidTaskTask.text, resource.text)
        .addValue(Dcterms.created, resource.createdAt)
        .addValues<VectorClockEntry>(
          SolidTaskTask.vectorClock,
          resource.vectorClock.entries.map(
            (e) => VectorClockEntry(e.key, e.value),
          ),
          serializer: VectorClockEntryMapper(
            storageRootProvider: _storageRootProvider,
            taskIdProvider: () => resource.id,
          ),
        )
        .addValue(SolidTaskTask.isDeleted, resource.isDeleted)
        .addValue(
          Dcterms.creator,
          resource.lastModifiedBy,
          serializer: _lastModifiedByMapper,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Item resource) {
    final id = resource.id;
    final storageRoot = _storageRootProvider();
    return '${storageRoot}/solidtask/task/${id}.ttl';
  }
}
