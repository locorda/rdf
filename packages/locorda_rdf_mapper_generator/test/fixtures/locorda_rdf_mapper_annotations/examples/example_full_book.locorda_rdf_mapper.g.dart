// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/rdf_mapper_annotations/examples/example_full_book.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'example_full_book.dart';
import 'package:locorda_rdf_terms_schema/schema.dart';
import 'package:locorda_rdf_terms_core/rdf.dart' as rdf;

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class BookAuthorIdMapper implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/author/(?<authorId>[^/]*)$',
  );

  /// Constructor
  const BookAuthorIdMapper();

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['authorId']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final authorId = iriTermValue.toString();
    return context.createIriTerm('http://example.org/author/${authorId}');
  }
}

/// Generated mapper for [Book] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Book`.
class BookMapper implements GlobalResourceMapper<Book> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/book/(?<id>[^/]*)$',
  );

  final IriTermMapper<String> _authorIdMapper;

  /// Constructor
  const BookMapper({
    IriTermMapper<String> authorIdMapper = const BookAuthorIdMapper(),
  }) : _authorIdMapper = authorIdMapper;

  @override
  IriTerm? get typeIri => SchemaBook.classIri;

  @override
  Book fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String title = reader.require(SchemaBook.name);
    final String authorId = reader.require(
      SchemaBook.author,
      deserializer: _authorIdMapper,
    );
    final DateTime published = reader.require(SchemaBook.datePublished);
    final ISBN isbn = reader.require(SchemaBook.isbn);
    final Rating rating = reader.require(SchemaBook.aggregateRating);
    final BookFormat? format = reader.optional(SchemaBook.bookFormat);
    final Iterable<Chapter> chapters = reader
        .requireCollection<Iterable<Chapter>, Chapter>(
          SchemaBook.hasPart,
          UnorderedItemsMapper.new,
        );

    return Book(
      id: id,
      title: title,
      authorId: authorId,
      published: published,
      isbn: isbn,
      rating: rating,
      format: format,
      chapters: chapters,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Book resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.name, resource.title)
        .addValue(
          SchemaBook.author,
          resource.authorId,
          serializer: _authorIdMapper,
        )
        .addValue(SchemaBook.datePublished, resource.published)
        .addValue(SchemaBook.isbn, resource.isbn)
        .addValue(SchemaBook.aggregateRating, resource.rating)
        .when(
          resource.format != null,
          (b) => b.addValue(SchemaBook.bookFormat, resource.format),
        )
        .addCollection<Iterable<Chapter>, Chapter>(
          SchemaBook.hasPart,
          resource.chapters,
          UnorderedItemsMapper.new,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Book resource) {
    final id = resource.id;
    return 'http://example.org/book/${id}';
  }
}

/// Generated mapper for [Chapter] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Chapter`.
class ChapterMapper implements LocalResourceMapper<Chapter> {
  /// Constructor
  const ChapterMapper();

  @override
  IriTerm? get typeIri => SchemaChapter.classIri;

  @override
  Chapter fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String title = reader.require(SchemaChapter.name);
    final int number = reader.require(SchemaChapter.position);

    return Chapter(title, number);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    Chapter resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaChapter.name, resource.title)
        .addValue(SchemaChapter.position, resource.number)
        .build();
  }
}

/// Generated mapper for [ISBN] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `ISBN`.
class ISBNMapper implements IriTermMapper<ISBN> {
  static final RegExp _regex = RegExp(r'^urn:isbn:(?<value>[^/]*)$');

  /// Constructor
  const ISBNMapper();

  @override
  ISBN fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final value = iriParts['value'];
    if (value == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return ISBN(value);
  }

  @override
  IriTerm toRdfTerm(
    ISBN iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final value = iriTermValue.value;
    return context.createIriTerm('urn:isbn:${value}');
  }
}

/// Generated mapper for [Rating] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type Rating.
class RatingMapper implements LiteralTermMapper<Rating> {
  final IriTerm? datatype = null;

  const RatingMapper();

  @override
  Rating fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    final int stars = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck: bypassDatatypeCheck,
    );

    return Rating(stars);
  }

  @override
  LiteralTerm toRdfTerm(
    Rating value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return context.toLiteralTerm(value.stars);
  }
}

/// Generated mapper for [BookFormat] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type BookFormat.
class BookFormatMapper implements IriTermMapper<BookFormat> {
  static final RegExp _regex = RegExp(r'^https://schema\.org/(?<value>[^/]*)$');

  /// Constructor
  const BookFormatMapper();

  @override
  BookFormat fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException('Unknown BookFormat IRI: ${term.value}');
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'AudiobookFormat' => BookFormat.audiobook,
      'Hardcover' => BookFormat.hardcover,
      'Paperback' => BookFormat.paperback,
      'Ebook' => BookFormat.ebook,
      'GraphicNovel' => BookFormat.graphicNovel,
      _ => throw DeserializationException(
        'Unknown BookFormat IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    BookFormat value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    BookFormat.audiobook => context.createIriTerm(_buildIri('AudiobookFormat')),
    BookFormat.hardcover => context.createIriTerm(_buildIri('Hardcover')),
    BookFormat.paperback => context.createIriTerm(_buildIri('Paperback')),
    BookFormat.ebook => context.createIriTerm(_buildIri('Ebook')),
    BookFormat.graphicNovel => context.createIriTerm(_buildIri('GraphicNovel')),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    return 'https://schema.org/${value}';
  }
}
