// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/locorda_rdf_mapper_annotations/examples/example_rdf_literal.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations
// ignore_for_file: depend_on_referenced_packages

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'example_rdf_literal.dart';
import 'package:locorda_rdf_terms_core/rdf.dart' as rdf;
import 'package:locorda_rdf_mapper_annotations/annotations.dart';

/// Generated mapper for [EnhancedRating] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type EnhancedRating.
class EnhancedRatingMapper implements LiteralTermMapper<EnhancedRating> {
  final IriTerm? datatype = null;

  const EnhancedRatingMapper();

  @override
  EnhancedRating fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    final int stars = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck: bypassDatatypeCheck,
    );

    return EnhancedRating(stars);
  }

  @override
  LiteralTerm toRdfTerm(
    EnhancedRating value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return context.toLiteralTerm(value.stars);
  }
}

/// Generated mapper for [Temperature] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type Temperature.
class TemperatureMapper implements LiteralTermMapper<Temperature> {
  final IriTerm? datatype = const IriTerm('http://example.org/temperature');

  const TemperatureMapper();

  @override
  Temperature fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    if (!bypassDatatypeCheck &&
        term.datatype != const IriTerm('http://example.org/temperature')) {
      throw DeserializerDatatypeMismatchException(
        'Failed to parse Temperature: ${term.value}. ',
        actual: term.datatype,
        expected: const IriTerm('http://example.org/temperature'),
        targetType: Temperature,
        mapperRuntimeType: this.runtimeType,
      );
    }
    return Temperature.parse(LiteralContent.fromLiteralTerm(term));
  }

  @override
  LiteralTerm toRdfTerm(
    Temperature value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return value.formatCelsius().toLiteralTerm(datatype);
  }
}

/// Generated mapper for [LocalizedText] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LocalizedText.
class LocalizedTextMapper implements LiteralTermMapper<LocalizedText> {
  final IriTerm? datatype = null;

  const LocalizedTextMapper();

  @override
  LocalizedText fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    if (!bypassDatatypeCheck && term.datatype != rdf.Rdf.langString) {
      throw DeserializerDatatypeMismatchException(
        'Failed to parse LocalizedText: ${term.value}. ',
        actual: term.datatype,
        expected: rdf.Rdf.langString,
        targetType: LocalizedText,
        mapperRuntimeType: this.runtimeType,
      );
    }
    final String text = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck:
          true /*we handle the actual final datatype ourselves, just delegate for convenience*/,
    );
    final String languageTag = term.language!;

    return LocalizedText(text, languageTag);
  }

  @override
  LiteralTerm toRdfTerm(
    LocalizedText value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm.withLanguage(
      context.toLiteralTerm(value.text).value,
      value.languageTag,
    );
  }
}
