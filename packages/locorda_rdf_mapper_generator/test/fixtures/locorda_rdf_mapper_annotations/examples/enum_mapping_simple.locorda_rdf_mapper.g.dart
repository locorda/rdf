// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/rdf_mapper_annotations/examples/enum_mapping_simple.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'enum_mapping_simple.dart';

/// Generated mapper for [Book] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Book`.
class BookMapper implements GlobalResourceMapper<Book> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/books/(?<sku>[^/]*)$',
  );

  final LiteralTermMapper<Priority> _priorityMapper;
  final LiteralTermMapper<ProductStatus> _statusMapper;

  /// Constructor
  const BookMapper({
    required LiteralTermMapper<Priority> customPriorityMapper,
    LiteralTermMapper<ProductStatus> statusMapper =
        const LanguageOverrideMapper<ProductStatus>('en'),
  }) : _priorityMapper = customPriorityMapper,
       _statusMapper = statusMapper;

  @override
  IriTerm? get typeIri => MyBookVocab.classIri;

  @override
  Book fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final sku = iriParts['sku'];
    if (sku == null) {
      throw DeserializationException(
        'Missing required IRI part: sku in IRI ${subject.value}',
      );
    }
    final BookFormat format = reader.require(MyBookVocab.bookFormat);
    final ItemCondition condition = reader.require(MyBookVocab.itemCondition);
    final Priority priority = reader.require(
      MyBookVocab.priority,
      deserializer: _priorityMapper,
    );
    final ProductStatus status = reader.require(
      MyBookVocab.status,
      deserializer: _statusMapper,
    );

    return Book(
      sku: sku,
      format: format,
      condition: condition,
      priority: priority,
      status: status,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Book resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(MyBookVocab.bookFormat, resource.format)
        .addValue(MyBookVocab.itemCondition, resource.condition)
        .addValue(
          MyBookVocab.priority,
          resource.priority,
          serializer: _priorityMapper,
        )
        .addValue(
          MyBookVocab.status,
          resource.status,
          serializer: _statusMapper,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Book resource) {
    final sku = resource.sku;
    return 'http://example.org/books/${sku}';
  }
}

/// Generated mapper for [BookFormat] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type BookFormat.
class BookFormatMapper implements LiteralTermMapper<BookFormat> {
  final IriTerm? datatype = null;

  const BookFormatMapper();

  @override
  BookFormat fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) => switch (term.value) {
    'hardcover' => BookFormat.hardcover,
    'paperback' => BookFormat.paperback,
    'ebook' => BookFormat.ebook,
    _ => throw DeserializationException(
      'Unknown BookFormat literal value: ${term.value}',
    ),
  };

  @override
  LiteralTerm toRdfTerm(
    BookFormat value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    BookFormat.hardcover => LiteralTerm('hardcover'),
    BookFormat.paperback => LiteralTerm('paperback'),
    BookFormat.ebook => LiteralTerm('ebook'),
  };
}

/// Generated mapper for [Priority] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type Priority.
class PriorityMapper implements LiteralTermMapper<Priority> {
  final IriTerm? datatype = null;

  const PriorityMapper();

  @override
  Priority fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) => switch (term.value) {
    'H' => Priority.high,
    'M' => Priority.medium,
    'L' => Priority.low,
    _ => throw DeserializationException(
      'Unknown Priority literal value: ${term.value}',
    ),
  };

  @override
  LiteralTerm toRdfTerm(
    Priority value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    Priority.high => LiteralTerm('H'),
    Priority.medium => LiteralTerm('M'),
    Priority.low => LiteralTerm('L'),
  };
}

/// Generated mapper for [ProductStatus] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type ProductStatus.
class ProductStatusMapper implements LiteralTermMapper<ProductStatus> {
  final IriTerm? datatype = null;

  const ProductStatusMapper();

  @override
  ProductStatus fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) => switch (term.value) {
    'available' => ProductStatus.inStock,
    'sold-out' => ProductStatus.outOfStock,
    'discontinued' => ProductStatus.discontinued,
    _ => throw DeserializationException(
      'Unknown ProductStatus literal value: ${term.value}',
    ),
  };

  @override
  LiteralTerm toRdfTerm(
    ProductStatus value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    ProductStatus.inStock => LiteralTerm('available'),
    ProductStatus.outOfStock => LiteralTerm('sold-out'),
    ProductStatus.discontinued => LiteralTerm('discontinued'),
  };
}

/// Generated mapper for [ItemCondition] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type ItemCondition.
class ItemConditionMapper implements IriTermMapper<ItemCondition> {
  static final RegExp _regex = RegExp(r'^http://schema\.org/(?<value>[^/]*)$');

  /// Constructor
  const ItemConditionMapper();

  @override
  ItemCondition fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException(
        'Unknown ItemCondition IRI: ${term.value}',
      );
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'NewCondition' => ItemCondition.brandNew,
      'UsedCondition' => ItemCondition.used,
      'refurbished' => ItemCondition.refurbished,
      _ => throw DeserializationException(
        'Unknown ItemCondition IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    ItemCondition value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    ItemCondition.brandNew => context.createIriTerm(_buildIri('NewCondition')),
    ItemCondition.used => context.createIriTerm(_buildIri('UsedCondition')),
    ItemCondition.refurbished => context.createIriTerm(
      _buildIri('refurbished'),
    ),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    return 'http://schema.org/${value}';
  }
}

/// Generated mapper for [OrderStatus] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type OrderStatus.
class OrderStatusMapper implements IriTermMapper<OrderStatus> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/vocab/order-status/(?<value>[^/]*)$',
  );

  /// Constructor
  const OrderStatusMapper();

  @override
  OrderStatus fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException('Unknown OrderStatus IRI: ${term.value}');
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'pending' => OrderStatus.pending,
      'in-progress' => OrderStatus.processing,
      'shipped' => OrderStatus.shipped,
      'delivered-completed' => OrderStatus.delivered,
      _ => throw DeserializationException(
        'Unknown OrderStatus IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    OrderStatus value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    OrderStatus.pending => context.createIriTerm(_buildIri('pending')),
    OrderStatus.processing => context.createIriTerm(_buildIri('in-progress')),
    OrderStatus.shipped => context.createIriTerm(_buildIri('shipped')),
    OrderStatus.delivered => context.createIriTerm(
      _buildIri('delivered-completed'),
    ),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    return 'http://example.org/vocab/order-status/${value}';
  }
}

/// Generated mapper for [CurrencyCode] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type CurrencyCode.
class CurrencyCodeMapper implements LiteralTermMapper<CurrencyCode> {
  final IriTerm? datatype = null;

  const CurrencyCodeMapper();

  @override
  CurrencyCode fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) => switch (term.value) {
    'USD' => CurrencyCode.usDollar,
    'EUR' => CurrencyCode.euro,
    'GBP' => CurrencyCode.britishPound,
    'JPY' => CurrencyCode.japaneseYen,
    _ => throw DeserializationException(
      'Unknown CurrencyCode literal value: ${term.value}',
    ),
  };

  @override
  LiteralTerm toRdfTerm(
    CurrencyCode value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    CurrencyCode.usDollar => LiteralTerm('USD'),
    CurrencyCode.euro => LiteralTerm('EUR'),
    CurrencyCode.britishPound => LiteralTerm('GBP'),
    CurrencyCode.japaneseYen => LiteralTerm('JPY'),
  };
}

/// Generated mapper for [BusinessEntityType] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type BusinessEntityType.
class BusinessEntityTypeMapper implements IriTermMapper<BusinessEntityType> {
  static final RegExp _regex = RegExp(
    r'^http://purl\.org/goodrelations/v1#(?<value>[^/]*)$',
  );

  /// Constructor
  const BusinessEntityTypeMapper();

  @override
  BusinessEntityType fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException(
        'Unknown BusinessEntityType IRI: ${term.value}',
      );
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'Business' => BusinessEntityType.business,
      'Enduser' => BusinessEntityType.endUser,
      'PublicInstitution' => BusinessEntityType.publicInstitution,
      'Reseller' => BusinessEntityType.reseller,
      _ => throw DeserializationException(
        'Unknown BusinessEntityType IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    BusinessEntityType value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    BusinessEntityType.business => context.createIriTerm(_buildIri('Business')),
    BusinessEntityType.endUser => context.createIriTerm(_buildIri('Enduser')),
    BusinessEntityType.publicInstitution => context.createIriTerm(
      _buildIri('PublicInstitution'),
    ),
    BusinessEntityType.reseller => context.createIriTerm(_buildIri('Reseller')),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    return 'http://purl.org/goodrelations/v1#${value}';
  }
}

/// Generated mapper for [UserRating] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type UserRating.
class UserRatingMapper implements IriTermMapper<UserRating> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/rating-system/(?<value>[^/]*)$',
  );

  /// Constructor
  const UserRatingMapper();

  @override
  UserRating fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException('Unknown UserRating IRI: ${term.value}');
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'excellent-5-stars' => UserRating.excellent,
      'good-4-stars' => UserRating.good,
      'average-3-stars' => UserRating.average,
      'poor-2-stars' => UserRating.poor,
      'terrible-1-star' => UserRating.terrible,
      _ => throw DeserializationException(
        'Unknown UserRating IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    UserRating value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    UserRating.excellent => context.createIriTerm(
      _buildIri('excellent-5-stars'),
    ),
    UserRating.good => context.createIriTerm(_buildIri('good-4-stars')),
    UserRating.average => context.createIriTerm(_buildIri('average-3-stars')),
    UserRating.poor => context.createIriTerm(_buildIri('poor-2-stars')),
    UserRating.terrible => context.createIriTerm(_buildIri('terrible-1-star')),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    return 'http://example.org/rating-system/${value}';
  }
}

/// Generated mapper for [ProductCategory] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type ProductCategory.
class ProductCategoryMapper implements IriTermMapper<ProductCategory> {
  static final RegExp _regex = RegExp(
    r'^(?<baseVocab>.*)/categories/(?<value>[^/]*)$',
  );

  final String Function() _baseVocabProvider;

  /// Constructor
  const ProductCategoryMapper({required String Function() baseVocabProvider})
    : _baseVocabProvider = baseVocabProvider;

  @override
  ProductCategory fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException(
        'Unknown ProductCategory IRI: ${term.value}',
      );
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'electronics' => ProductCategory.electronics,
      'books-media' => ProductCategory.booksAndMedia,
      'clothing' => ProductCategory.clothing,
      'home-garden' => ProductCategory.homeAndGarden,
      _ => throw DeserializationException(
        'Unknown ProductCategory IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    ProductCategory value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    ProductCategory.electronics => context.createIriTerm(
      _buildIri('electronics'),
    ),
    ProductCategory.booksAndMedia => context.createIriTerm(
      _buildIri('books-media'),
    ),
    ProductCategory.clothing => context.createIriTerm(_buildIri('clothing')),
    ProductCategory.homeAndGarden => context.createIriTerm(
      _buildIri('home-garden'),
    ),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    final baseVocab = _baseVocabProvider();
    return '${baseVocab}/categories/${value}';
  }
}

/// Generated mapper for [ShippingMethod] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type ShippingMethod.
class ShippingMethodMapper implements IriTermMapper<ShippingMethod> {
  static final RegExp _regex = RegExp(
    r'^(?<apiBase>.*)/(?<version>[^/]*)/shipping-methods/(?<value>[^/]*)$',
  );

  final String Function() _apiBaseProvider;
  final String Function() _versionProvider;

  /// Constructor
  const ShippingMethodMapper({
    required String Function() apiBaseProvider,
    required String Function() versionProvider,
  }) : _apiBaseProvider = apiBaseProvider,
       _versionProvider = versionProvider;

  @override
  ShippingMethod fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException(
        'Unknown ShippingMethod IRI: ${term.value}',
      );
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'standard' => ShippingMethod.standard,
      'express-overnight' => ShippingMethod.express,
      'same-day-delivery' => ShippingMethod.sameDay,
      'pickup-in-store' => ShippingMethod.pickup,
      _ => throw DeserializationException(
        'Unknown ShippingMethod IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    ShippingMethod value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    ShippingMethod.standard => context.createIriTerm(_buildIri('standard')),
    ShippingMethod.express => context.createIriTerm(
      _buildIri('express-overnight'),
    ),
    ShippingMethod.sameDay => context.createIriTerm(
      _buildIri('same-day-delivery'),
    ),
    ShippingMethod.pickup => context.createIriTerm(
      _buildIri('pickup-in-store'),
    ),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    final apiBase = _apiBaseProvider();
    final version = _versionProvider();
    return '${apiBase}/${version}/shipping-methods/${value}';
  }
}

/// Generated mapper for [EmployeeRole] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type EmployeeRole.
class EmployeeRoleMapper implements IriTermMapper<EmployeeRole> {
  static final RegExp _regex = RegExp(
    r'^(?<orgNamespace>.*)/departments/(?<department>[^/]*)/roles/(?<value>[^/]*)$',
  );

  final String Function() _departmentProvider;
  final String Function() _orgNamespaceProvider;

  /// Constructor
  const EmployeeRoleMapper({
    required String Function() departmentProvider,
    required String Function() orgNamespaceProvider,
  }) : _departmentProvider = departmentProvider,
       _orgNamespaceProvider = orgNamespaceProvider;

  @override
  EmployeeRole fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException('Unknown EmployeeRole IRI: ${term.value}');
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'manager' => EmployeeRole.manager,
      'team-lead' => EmployeeRole.teamLead,
      'developer' => EmployeeRole.developer,
      'quality-assurance' => EmployeeRole.qualityAssurance,
      _ => throw DeserializationException(
        'Unknown EmployeeRole IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    EmployeeRole value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    EmployeeRole.manager => context.createIriTerm(_buildIri('manager')),
    EmployeeRole.teamLead => context.createIriTerm(_buildIri('team-lead')),
    EmployeeRole.developer => context.createIriTerm(_buildIri('developer')),
    EmployeeRole.qualityAssurance => context.createIriTerm(
      _buildIri('quality-assurance'),
    ),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    final orgNamespace = _orgNamespaceProvider();
    final department = _departmentProvider();
    return '${orgNamespace}/departments/${department}/roles/${value}';
  }
}
