// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/rdf_mapper_annotations/examples/collection_examples.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'collection_examples.dart';
import 'package:locorda_rdf_terms_schema/schema.dart';

/// Generated mapper for [Library] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Library`.
class LibraryMapper implements GlobalResourceMapper<Library> {
  static final RegExp _regex = RegExp(r'^(?<baseUri>.*)/library/(?<id>[^/]*)$');

  final String Function() _baseUriProvider;

  /// Constructor
  const LibraryMapper({required String Function() baseUriProvider})
    : _baseUriProvider = baseUriProvider;

  @override
  IriTerm? get typeIri => CollectionVocab.Library;

  @override
  Library fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final List<Book> books = reader.requireCollection<List<Book>, Book>(
      CollectionVocab.books,
      UnorderedItemsListMapper.new,
    );
    final Iterable<String> collaborators = reader
        .requireCollection<Iterable<String>, String>(
          CollectionVocab.collaborators,
          UnorderedItemsMapper.new,
        );

    return Library(id: id, books: books, collaborators: collaborators);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Library resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addCollection<List<Book>, Book>(
          CollectionVocab.books,
          resource.books,
          UnorderedItemsListMapper.new,
        )
        .addCollection<Iterable<String>, String>(
          CollectionVocab.collaborators,
          resource.collaborators,
          UnorderedItemsMapper.new,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Library resource) {
    final id = resource.id;
    final baseUri = _baseUriProvider();
    return '${baseUri}/library/${id}';
  }
}

/// Generated mapper for [Playlist] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Playlist`.
class PlaylistMapper implements GlobalResourceMapper<Playlist> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/playlist/(?<id>[^/]*)$',
  );

  final String Function() _baseUriProvider;

  /// Constructor
  const PlaylistMapper({required String Function() baseUriProvider})
    : _baseUriProvider = baseUriProvider;

  @override
  IriTerm? get typeIri => CollectionVocab.Playlist;

  @override
  Playlist fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final List<Track> orderedTracks = reader
        .requireCollection<List<Track>, Track>(
          CollectionVocab.orderedTracks,
          RdfListMapper.new,
        );

    return Playlist(id: id, orderedTracks: orderedTracks);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Playlist resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addCollection<List<Track>, Track>(
          CollectionVocab.orderedTracks,
          resource.orderedTracks,
          RdfListMapper.new,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Playlist resource) {
    final id = resource.id;
    final baseUri = _baseUriProvider();
    return '${baseUri}/playlist/${id}';
  }
}

/// Generated mapper for [Course] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Course`.
class CourseMapper implements GlobalResourceMapper<Course> {
  static final RegExp _regex = RegExp(r'^(?<baseUri>.*)/course/(?<id>[^/]*)$');

  final String Function() _baseUriProvider;

  /// Constructor
  const CourseMapper({required String Function() baseUriProvider})
    : _baseUriProvider = baseUriProvider;

  @override
  IriTerm? get typeIri => CollectionVocab.Course;

  @override
  Course fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final List<Module> modules = reader.requireCollection<List<Module>, Module>(
      CollectionVocab.modules,
      RdfSeqMapper.new,
    );
    final List<String> prerequisites = reader
        .requireCollection<List<String>, String>(
          CollectionVocab.prerequisites,
          RdfBagMapper.new,
        );
    final List<String> alternatives = reader
        .requireCollection<List<String>, String>(
          CollectionVocab.alternatives,
          RdfAltMapper.new,
        );

    return Course(
      id: id,
      modules: modules,
      prerequisites: prerequisites,
      alternatives: alternatives,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Course resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addCollection<List<Module>, Module>(
          CollectionVocab.modules,
          resource.modules,
          RdfSeqMapper.new,
        )
        .addCollection<List<String>, String>(
          CollectionVocab.prerequisites,
          resource.prerequisites,
          RdfBagMapper.new,
        )
        .addCollection<List<String>, String>(
          CollectionVocab.alternatives,
          resource.alternatives,
          RdfAltMapper.new,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Course resource) {
    final id = resource.id;
    final baseUri = _baseUriProvider();
    return '${baseUri}/course/${id}';
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class BookCollectionAuthorIdsMapper implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/author/(?<authorIds>[^/]*)$',
  );

  final String Function() _baseUriProvider;

  /// Constructor
  const BookCollectionAuthorIdsMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['authorIds']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final authorIds = iriTermValue.toString();
    final baseUri = _baseUriProvider();
    return context.createIriTerm('${baseUri}/author/${authorIds}');
  }
}

/// Generated mapper for [BookCollection] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `BookCollection`.
class BookCollectionMapper implements LocalResourceMapper<BookCollection> {
  late final IriTermMapper<String> _authorIdsMapper;
  final String Function() _baseUriProvider;
  final LiteralTermMapper<String> _keywordsMapper;
  final LiteralTermMapper<DateTime> _publicationDatesMapper;

  /// Constructor
  BookCollectionMapper({
    required String Function() baseUriProvider,
    LiteralTermMapper<String> keywordsMapper =
        const LanguageOverrideMapper<String>('en'),
    LiteralTermMapper<DateTime> publicationDatesMapper =
        const DatatypeOverrideMapper<DateTime>(
          const IriTerm('http://www.w3.org/2001/XMLSchema#date'),
        ),
  }) : _baseUriProvider = baseUriProvider,
       _keywordsMapper = keywordsMapper,
       _publicationDatesMapper = publicationDatesMapper {
    _authorIdsMapper = BookCollectionAuthorIdsMapper(
      baseUriProvider: baseUriProvider,
    );
  }

  @override
  IriTerm? get typeIri => null;

  @override
  BookCollection fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> authorIds = reader
        .requireCollection<List<String>, String>(
          SchemaBook.author,
          UnorderedItemsListMapper.new,
          itemDeserializer: _authorIdsMapper,
        );
    final List<String> keywords = reader
        .requireCollection<List<String>, String>(
          SchemaBook.keywords,
          UnorderedItemsListMapper.new,
          itemDeserializer: _keywordsMapper,
        );
    final List<DateTime> publicationDates = reader
        .requireCollection<List<DateTime>, DateTime>(
          SchemaBook.datePublished,
          RdfListMapper.new,
          itemDeserializer: _publicationDatesMapper,
        );

    return BookCollection(
      authorIds: authorIds,
      keywords: keywords,
      publicationDates: publicationDates,
    );
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    BookCollection resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addCollection<List<String>, String>(
          SchemaBook.author,
          resource.authorIds,
          UnorderedItemsListMapper.new,
          itemSerializer: _authorIdsMapper,
        )
        .addCollection<List<String>, String>(
          SchemaBook.keywords,
          resource.keywords,
          UnorderedItemsListMapper.new,
          itemSerializer: _keywordsMapper,
        )
        .addCollection<List<DateTime>, DateTime>(
          SchemaBook.datePublished,
          resource.publicationDates,
          RdfListMapper.new,
          itemSerializer: _publicationDatesMapper,
        )
        .build();
  }
}

/// Generated mapper for [Book] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Book`.
class BookMapper implements LocalResourceMapper<Book> {
  /// Constructor
  const BookMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  Book fromRdfResource(BlankNodeTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final String title = reader.require(SchemaBook.name);
    final String author = reader.require(SchemaBook.author);

    return Book(title: title, author: author);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    Book resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.name, resource.title)
        .addValue(SchemaBook.author, resource.author)
        .build();
  }
}

/// Generated mapper for [Track] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Track`.
class TrackMapper implements LocalResourceMapper<Track> {
  /// Constructor
  const TrackMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  Track fromRdfResource(BlankNodeTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final String title = reader.require(SchemaMediaObject.name);
    final Duration duration = reader.require(SchemaMediaObject.duration);

    return Track(title: title, duration: duration);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    Track resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaMediaObject.name, resource.title)
        .addValue(SchemaMediaObject.duration, resource.duration)
        .build();
  }
}

/// Generated mapper for [Module] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Module`.
class ModuleMapper implements LocalResourceMapper<Module> {
  /// Constructor
  const ModuleMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  Module fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String name = reader.require(SchemaCreativeWork.name);
    final int position = reader.require(SchemaCreativeWork.position);

    return Module(name: name, position: position);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    Module resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaCreativeWork.name, resource.name)
        .addValue(SchemaCreativeWork.position, resource.position)
        .build();
  }
}
