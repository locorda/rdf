// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/annotation_subclass_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations
// ignore_for_file: depend_on_referenced_packages

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'annotation_subclass_test_models.dart';
import 'package:locorda_rdf_terms_schema/schema.dart';

/// Generated mapper for [BookWithCustomAnnotation] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `BookWithCustomAnnotation`.
class BookWithCustomAnnotationMapper
    implements GlobalResourceMapper<BookWithCustomAnnotation> {
  static final RegExp _regex = RegExp(r'^https://example\.com/(?<id>[^/]*)$');

  /// Constructor
  const BookWithCustomAnnotationMapper();

  @override
  IriTerm? get typeIri => SchemaBook.classIri;

  @override
  BookWithCustomAnnotation fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String title = reader.require(SchemaBook.name);
    final String author = reader.require(SchemaBook.author);

    return BookWithCustomAnnotation(id: id, title: title, author: author);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    BookWithCustomAnnotation resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.name, resource.title)
        .addValue(SchemaBook.author, resource.author)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(BookWithCustomAnnotation resource) {
    final id = resource.id;
    return 'https://example.com/${id}';
  }
}

/// Generated mapper for [PersonWithPodResource] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `PersonWithPodResource`.
class PersonWithPodResourceMapper
    implements GlobalResourceMapper<PersonWithPodResource> {
  static final RegExp _regex = RegExp(
    r'^https://pod\.example\.com/(?<id>[^/]*)$',
  );

  /// Constructor
  const PersonWithPodResourceMapper();

  @override
  IriTerm? get typeIri => SchemaPerson.classIri;

  @override
  PersonWithPodResource fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String name = reader.require(SchemaPerson.name);

    return PersonWithPodResource(id: id, name: name);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    PersonWithPodResource resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(SchemaPerson.name, resource.name)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(PersonWithPodResource resource) {
    final id = resource.id;
    return 'https://pod.example.com/${id}';
  }
}

/// Generated mapper for [PersonWithPodResource2] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `PersonWithPodResource2`.
class PersonWithPodResource2Mapper
    implements GlobalResourceMapper<PersonWithPodResource2> {
  final IriTermMapper<(String id,)> _iriMapper;

  /// Constructor
  const PersonWithPodResource2Mapper({
    required IriTermMapper<(String id,)> iriMapper,
  }) : _iriMapper = iriMapper;

  @override
  IriTerm? get typeIri => SchemaPerson.classIri;

  @override
  PersonWithPodResource2 fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final (id,) = _iriMapper.fromRdfTerm(subject, context);

    final String name = reader.require(SchemaPerson.name);

    return PersonWithPodResource2(id: id, name: name);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    PersonWithPodResource2 resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = _iriMapper.toRdfTerm((resource.id,), context);

    return context
        .resourceBuilder(subject)
        .addValue(SchemaPerson.name, resource.name)
        .build();
  }
}

/// Generated mapper for [ArticleWithRegularAnnotation] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `ArticleWithRegularAnnotation`.
class ArticleWithRegularAnnotationMapper
    implements GlobalResourceMapper<ArticleWithRegularAnnotation> {
  static final RegExp _regex = RegExp(
    r'^https://example\.com/articles/(?<id>[^/]*)$',
  );

  /// Constructor
  const ArticleWithRegularAnnotationMapper();

  @override
  IriTerm? get typeIri => SchemaArticle.classIri;

  @override
  ArticleWithRegularAnnotation fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String title = reader.require(SchemaArticle.name);

    return ArticleWithRegularAnnotation(id: id, title: title);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    ArticleWithRegularAnnotation resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(SchemaArticle.name, resource.title)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ArticleWithRegularAnnotation resource) {
    final id = resource.id;
    return 'https://example.com/articles/${id}';
  }
}
