// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/literal_processor_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:locorda_rdf_core/core.dart';
import 'package:locorda_rdf_mapper/mapper.dart';

// Other imports
import 'literal_processor_test_models.dart';
import 'package:locorda_rdf_terms_core/rdf.dart' as rdf;
import 'package:locorda_rdf_terms_core/xsd.dart';
import 'package:locorda_rdf_mapper_annotations/annotations.dart';

/// Generated mapper for [LiteralString] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LiteralString.
class LiteralStringMapper implements LiteralTermMapper<LiteralString> {
  final IriTerm? datatype = null;

  const LiteralStringMapper();

  @override
  LiteralString fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    final String foo = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck: bypassDatatypeCheck,
    );

    return LiteralString(foo: foo);
  }

  @override
  LiteralTerm toRdfTerm(
    LiteralString value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return context.toLiteralTerm(value.foo);
  }
}

/// Generated mapper for [Rating] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type Rating.
class RatingMapper implements LiteralTermMapper<Rating> {
  final IriTerm? datatype = null;

  const RatingMapper();

  @override
  Rating fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    final int stars = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck: bypassDatatypeCheck,
    );

    return Rating(stars);
  }

  @override
  LiteralTerm toRdfTerm(
    Rating value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return context.toLiteralTerm(value.stars);
  }
}

/// Generated mapper for [LocalizedText] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LocalizedText.
class LocalizedTextMapper implements LiteralTermMapper<LocalizedText> {
  final IriTerm? datatype = null;

  const LocalizedTextMapper();

  @override
  LocalizedText fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    if (!bypassDatatypeCheck && term.datatype != rdf.Rdf.langString) {
      throw DeserializerDatatypeMismatchException(
        'Failed to parse LocalizedText: ${term.value}. ',
        actual: term.datatype,
        expected: rdf.Rdf.langString,
        targetType: LocalizedText,
        mapperRuntimeType: this.runtimeType,
      );
    }
    final String text = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck:
          true /*we handle the actual final datatype ourselves, just delegate for convenience*/,
    );
    final String language = term.language!;

    return LocalizedText(text, language);
  }

  @override
  LiteralTerm toRdfTerm(
    LocalizedText value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm.withLanguage(
      context.toLiteralTerm(value.text).value,
      value.language,
    );
  }
}

/// Generated mapper for [LiteralDouble] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LiteralDouble.
class LiteralDoubleMapper implements LiteralTermMapper<LiteralDouble> {
  final IriTerm? datatype = Xsd.double;

  const LiteralDoubleMapper();

  @override
  LiteralDouble fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    if (!bypassDatatypeCheck && term.datatype != Xsd.double) {
      throw DeserializerDatatypeMismatchException(
        'Failed to parse LiteralDouble: ${term.value}. ',
        actual: term.datatype,
        expected: Xsd.double,
        targetType: LiteralDouble,
        mapperRuntimeType: this.runtimeType,
      );
    }
    final double foo = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck:
          true /*we handle the actual final datatype ourselves, just delegate for convenience*/,
    );

    return LiteralDouble(foo: foo);
  }

  @override
  LiteralTerm toRdfTerm(
    LiteralDouble value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm(
      context.toLiteralTerm(value.foo).value,
      datatype: Xsd.double,
    );
  }
}

/// Generated mapper for [LiteralInteger] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LiteralInteger.
class LiteralIntegerMapper implements LiteralTermMapper<LiteralInteger> {
  final IriTerm? datatype = Xsd.integer;

  const LiteralIntegerMapper();

  @override
  LiteralInteger fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    if (!bypassDatatypeCheck && term.datatype != Xsd.integer) {
      throw DeserializerDatatypeMismatchException(
        'Failed to parse LiteralInteger: ${term.value}. ',
        actual: term.datatype,
        expected: Xsd.integer,
        targetType: LiteralInteger,
        mapperRuntimeType: this.runtimeType,
      );
    }
    final int value = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck:
          true /*we handle the actual final datatype ourselves, just delegate for convenience*/,
    );

    return LiteralInteger(value: value);
  }

  @override
  LiteralTerm toRdfTerm(
    LiteralInteger value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm(
      context.toLiteralTerm(value.value).value,
      datatype: Xsd.integer,
    );
  }
}

/// Generated mapper for [Temperature] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type Temperature.
class TemperatureMapper implements LiteralTermMapper<Temperature> {
  final IriTerm? datatype = null;

  const TemperatureMapper();

  @override
  Temperature fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    return Temperature.parse(LiteralContent.fromLiteralTerm(term));
  }

  @override
  LiteralTerm toRdfTerm(
    Temperature value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return value.formatCelsius().toLiteralTerm(datatype);
  }
}

/// Generated mapper for [CustomLocalizedText] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type CustomLocalizedText.
class CustomLocalizedTextMapper
    implements LiteralTermMapper<CustomLocalizedText> {
  final IriTerm? datatype = null;

  const CustomLocalizedTextMapper();

  @override
  CustomLocalizedText fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    return CustomLocalizedText.fromRdf(LiteralContent.fromLiteralTerm(term));
  }

  @override
  LiteralTerm toRdfTerm(
    CustomLocalizedText value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return value.toRdf().toLiteralTerm(datatype);
  }
}

/// Generated mapper for [DoubleAsMilliunit] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type DoubleAsMilliunit.
class DoubleAsMilliunitMapper implements LiteralTermMapper<DoubleAsMilliunit> {
  final IriTerm? datatype = Xsd.int;

  const DoubleAsMilliunitMapper();

  @override
  DoubleAsMilliunit fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    if (!bypassDatatypeCheck && term.datatype != Xsd.int) {
      throw DeserializerDatatypeMismatchException(
        'Failed to parse DoubleAsMilliunit: ${term.value}. ',
        actual: term.datatype,
        expected: Xsd.int,
        targetType: DoubleAsMilliunit,
        mapperRuntimeType: this.runtimeType,
      );
    }
    return DoubleAsMilliunit.fromMilliunit(
      LiteralContent.fromLiteralTerm(term),
    );
  }

  @override
  LiteralTerm toRdfTerm(
    DoubleAsMilliunit value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return value.toMilliunit().toLiteralTerm(datatype);
  }
}

/// Generated mapper for [LiteralWithNonConstructorValue] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LiteralWithNonConstructorValue.
class LiteralWithNonConstructorValueMapper
    implements LiteralTermMapper<LiteralWithNonConstructorValue> {
  final IriTerm? datatype = null;

  const LiteralWithNonConstructorValueMapper();

  @override
  LiteralWithNonConstructorValue fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    final String value = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck: bypassDatatypeCheck,
    );

    final retval = LiteralWithNonConstructorValue();
    retval.value = value;
    return retval;
  }

  @override
  LiteralTerm toRdfTerm(
    LiteralWithNonConstructorValue value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return context.toLiteralTerm(value.value);
  }
}

/// Generated mapper for [LocalizedTextWithNonConstructorLanguage] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LocalizedTextWithNonConstructorLanguage.
class LocalizedTextWithNonConstructorLanguageMapper
    implements LiteralTermMapper<LocalizedTextWithNonConstructorLanguage> {
  final IriTerm? datatype = null;

  const LocalizedTextWithNonConstructorLanguageMapper();

  @override
  LocalizedTextWithNonConstructorLanguage fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    if (!bypassDatatypeCheck && term.datatype != rdf.Rdf.langString) {
      throw DeserializerDatatypeMismatchException(
        'Failed to parse LocalizedTextWithNonConstructorLanguage: ${term.value}. ',
        actual: term.datatype,
        expected: rdf.Rdf.langString,
        targetType: LocalizedTextWithNonConstructorLanguage,
        mapperRuntimeType: this.runtimeType,
      );
    }
    final String text = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck:
          true /*we handle the actual final datatype ourselves, just delegate for convenience*/,
    );
    final String language = term.language!;

    final retval = LocalizedTextWithNonConstructorLanguage(text);
    retval.language = language;
    return retval;
  }

  @override
  LiteralTerm toRdfTerm(
    LocalizedTextWithNonConstructorLanguage value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm.withLanguage(
      context.toLiteralTerm(value.text).value,
      value.language,
    );
  }
}

/// Generated mapper for [LiteralLateFinalLocalizedText] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LiteralLateFinalLocalizedText.
class LiteralLateFinalLocalizedTextMapper
    implements LiteralTermMapper<LiteralLateFinalLocalizedText> {
  final IriTerm? datatype = null;

  const LiteralLateFinalLocalizedTextMapper();

  @override
  LiteralLateFinalLocalizedText fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    if (!bypassDatatypeCheck && term.datatype != rdf.Rdf.langString) {
      throw DeserializerDatatypeMismatchException(
        'Failed to parse LiteralLateFinalLocalizedText: ${term.value}. ',
        actual: term.datatype,
        expected: rdf.Rdf.langString,
        targetType: LiteralLateFinalLocalizedText,
        mapperRuntimeType: this.runtimeType,
      );
    }
    final String baseValue = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck:
          true /*we handle the actual final datatype ourselves, just delegate for convenience*/,
    );
    final String language = term.language!;

    final retval = LiteralLateFinalLocalizedText();
    retval.baseValue = baseValue;
    retval.language = language;
    return retval;
  }

  @override
  LiteralTerm toRdfTerm(
    LiteralLateFinalLocalizedText value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm.withLanguage(
      context.toLiteralTerm(value.baseValue).value,
      value.language,
    );
  }
}
