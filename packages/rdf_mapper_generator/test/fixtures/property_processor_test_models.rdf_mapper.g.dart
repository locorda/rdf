// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/property_processor_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'property_processor_test_models.dart';
import 'package:rdf_vocabularies_schema/schema.dart';
import 'package:rdf_vocabularies_core/xsd.dart';

/// Generated mapper for [SimplePropertyTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `SimplePropertyTest`.
class SimplePropertyTestMapper
    implements LocalResourceMapper<SimplePropertyTest> {
  /// Constructor
  const SimplePropertyTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  SimplePropertyTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String name = reader.require(SchemaBook.name);

    return SimplePropertyTest(name: name);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    SimplePropertyTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.name, resource.name)
        .build();
  }
}

/// Generated mapper for [SimpleCustomPropertyTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `SimpleCustomPropertyTest`.
class SimpleCustomPropertyTestMapper
    implements GlobalResourceMapper<SimpleCustomPropertyTest> {
  /// Constructor
  const SimpleCustomPropertyTestMapper();

  @override
  IriTerm? get typeIri => const IriTerm('http://example.org/types/Book');

  @override
  SimpleCustomPropertyTest fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String name = reader.require(
      const IriTerm('http://example.org/types/Book/name'),
    );

    return SimpleCustomPropertyTest(name: name);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    SimpleCustomPropertyTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('http://example.org/types/Book/name'),
          resource.name,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(SimpleCustomPropertyTest resource) {
    final name = resource.name;
    return 'http://example.org/books/${name}';
  }
}

/// Generated mapper for [DeserializationOnlyPropertyTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `DeserializationOnlyPropertyTest`.
class DeserializationOnlyPropertyTestMapper
    implements LocalResourceMapper<DeserializationOnlyPropertyTest> {
  /// Constructor
  const DeserializationOnlyPropertyTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  DeserializationOnlyPropertyTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String name = reader.require(SchemaBook.name);

    return DeserializationOnlyPropertyTest(name: name);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    DeserializationOnlyPropertyTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context.resourceBuilder(subject).build();
  }
}

/// Generated mapper for [OptionalPropertyTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `OptionalPropertyTest`.
class OptionalPropertyTestMapper
    implements LocalResourceMapper<OptionalPropertyTest> {
  /// Constructor
  const OptionalPropertyTestMapper();

  @override
  IriTerm? get typeIri => SchemaBook.classIri;

  @override
  OptionalPropertyTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String? name = reader.optional(SchemaBook.name);

    return OptionalPropertyTest(name: name);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    OptionalPropertyTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .when(
          resource.name != null,
          (b) => b.addValue(SchemaBook.name, resource.name),
        )
        .build();
  }
}

/// Generated mapper for [DefaultValueTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `DefaultValueTest`.
class DefaultValueTestMapper implements GlobalResourceMapper<DefaultValueTest> {
  /// Constructor
  const DefaultValueTestMapper();

  @override
  IriTerm? get typeIri => SchemaBook.classIri;

  @override
  DefaultValueTest fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String isbn = reader.optional(SchemaBook.isbn) ?? 'default-isbn';

    return DefaultValueTest(isbn: isbn);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    DefaultValueTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .when(
          resource.isbn != 'default-isbn',
          (b) => b.addValue(SchemaBook.isbn, resource.isbn),
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(DefaultValueTest resource) {
    return 'http://example.org/books/singleton';
  }
}

/// Generated mapper for [IncludeDefaultsTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `IncludeDefaultsTest`.
class IncludeDefaultsTestMapper
    implements LocalResourceMapper<IncludeDefaultsTest> {
  /// Constructor
  const IncludeDefaultsTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  IncludeDefaultsTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final int rating = reader.optional(SchemaBook.numberOfPages) ?? 5;

    return IncludeDefaultsTest(rating: rating);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    IncludeDefaultsTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.numberOfPages, resource.rating)
        .build();
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class IriMappingTestAuthorIdMapper implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/authors/(?<authorId>[^/]*)$',
  );

  /// Constructor
  const IriMappingTestAuthorIdMapper();

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['authorId']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final authorId = iriTermValue.toString();
    return context.createIriTerm('http://example.org/authors/${authorId}');
  }
}

/// Generated mapper for [IriMappingTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `IriMappingTest`.
class IriMappingTestMapper implements LocalResourceMapper<IriMappingTest> {
  final IriTermMapper<String> _authorIdMapper;

  /// Constructor
  const IriMappingTestMapper({
    IriTermMapper<String> authorIdMapper = const IriMappingTestAuthorIdMapper(),
  }) : _authorIdMapper = authorIdMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  IriMappingTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String authorId = reader.require(
      SchemaBook.author,
      deserializer: _authorIdMapper,
    );

    return IriMappingTest(authorId: authorId);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    IriMappingTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.author,
          resource.authorId,
          serializer: _authorIdMapper,
        )
        .build();
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class IriMappingWithBaseUriTestAuthorIdMapper implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/authors/(?<authorId>[^/]*)$',
  );

  final String Function() _baseUriProvider;

  /// Constructor
  const IriMappingWithBaseUriTestAuthorIdMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['authorId']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final authorId = iriTermValue.toString();
    final baseUri = _baseUriProvider();
    return context.createIriTerm('${baseUri}/authors/${authorId}');
  }
}

/// Generated mapper for [IriMappingWithBaseUriTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `IriMappingWithBaseUriTest`.
class IriMappingWithBaseUriTestMapper
    implements LocalResourceMapper<IriMappingWithBaseUriTest> {
  late final IriTermMapper<String> _authorIdMapper;
  final String Function() _baseUriProvider;

  /// Constructor
  IriMappingWithBaseUriTestMapper({required String Function() baseUriProvider})
    : _baseUriProvider = baseUriProvider {
    _authorIdMapper = IriMappingWithBaseUriTestAuthorIdMapper(
      baseUriProvider: baseUriProvider,
    );
  }

  @override
  IriTerm? get typeIri => null;

  @override
  IriMappingWithBaseUriTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String authorId = reader.require(
      SchemaBook.author,
      deserializer: _authorIdMapper,
    );

    return IriMappingWithBaseUriTest(authorId: authorId);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    IriMappingWithBaseUriTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.author,
          resource.authorId,
          serializer: _authorIdMapper,
        )
        .build();
  }
}

/// Generated mapper for [IriMappingFullIriTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `IriMappingFullIriTest`.
class IriMappingFullIriTestMapper
    implements LocalResourceMapper<IriMappingFullIriTest> {
  final IriTermMapper<String> _authorIriMapper;

  /// Constructor
  const IriMappingFullIriTestMapper({
    IriTermMapper<String> authorIriMapper = const IriFullMapper(),
  }) : _authorIriMapper = authorIriMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  IriMappingFullIriTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String authorIri = reader.require(
      SchemaBook.author,
      deserializer: _authorIriMapper,
    );

    return IriMappingFullIriTest(authorIri: authorIri);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    IriMappingFullIriTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.author,
          resource.authorIri,
          serializer: _authorIriMapper,
        )
        .build();
  }
}

/// Generated mapper for [IriMappingFullIriSimpleTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `IriMappingFullIriSimpleTest`.
class IriMappingFullIriSimpleTestMapper
    implements LocalResourceMapper<IriMappingFullIriSimpleTest> {
  final IriTermMapper<String> _authorIriMapper;

  /// Constructor
  const IriMappingFullIriSimpleTestMapper({
    IriTermMapper<String> authorIriMapper = const IriFullMapper(),
  }) : _authorIriMapper = authorIriMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  IriMappingFullIriSimpleTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String authorIri = reader.require(
      SchemaBook.author,
      deserializer: _authorIriMapper,
    );

    return IriMappingFullIriSimpleTest(authorIri: authorIri);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    IriMappingFullIriSimpleTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.author,
          resource.authorIri,
          serializer: _authorIriMapper,
        )
        .build();
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class IriMappingWithProviderTestAuthorIdMapper
    implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/(?<category>[^/]*)/(?<authorId>[^/]*)$',
  );

  final String Function() _categoryProvider;

  /// Constructor
  const IriMappingWithProviderTestAuthorIdMapper({
    required String Function() categoryProvider,
  }) : _categoryProvider = categoryProvider;

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['authorId']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final authorId = iriTermValue.toString();
    final category = _categoryProvider();
    return context.createIriTerm('http://example.org/${category}/${authorId}');
  }
}

/// Generated mapper for [IriMappingWithProviderTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `IriMappingWithProviderTest`.
class IriMappingWithProviderTestMapper
    implements LocalResourceMapper<IriMappingWithProviderTest> {
  /// Constructor
  const IriMappingWithProviderTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  IriMappingWithProviderTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String authorId = reader.require(
      SchemaBook.author,
      deserializer: IriMappingWithProviderTestAuthorIdMapper(
        categoryProvider: () =>
            throw Exception('Must not call provider for deserialization'),
      ),
    );

    return IriMappingWithProviderTest(authorId: authorId);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    IriMappingWithProviderTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.author,
          resource.authorId,
          serializer: IriMappingWithProviderTestAuthorIdMapper(
            categoryProvider: () => resource.category,
          ),
        )
        .build();
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class IriMappingWithBaseUriProviderTestAuthorIdMapper
    implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(r'^(?<baseUri>.*)/(?<authorId>[^/]*)$');

  final String Function() _baseUriProvider;

  /// Constructor
  const IriMappingWithBaseUriProviderTestAuthorIdMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['authorId']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final authorId = iriTermValue.toString();
    final baseUri = _baseUriProvider();
    return context.createIriTerm('${baseUri}/${authorId}');
  }
}

/// Generated mapper for [IriMappingWithBaseUriProviderTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `IriMappingWithBaseUriProviderTest`.
class IriMappingWithBaseUriProviderTestMapper
    implements LocalResourceMapper<IriMappingWithBaseUriProviderTest> {
  /// Constructor
  const IriMappingWithBaseUriProviderTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  IriMappingWithBaseUriProviderTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String authorId = reader.require(
      SchemaBook.author,
      deserializer: IriMappingWithBaseUriProviderTestAuthorIdMapper(
        baseUriProvider: () =>
            throw Exception('Must not call provider for deserialization'),
      ),
    );

    return IriMappingWithBaseUriProviderTest(authorId: authorId);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    IriMappingWithBaseUriProviderTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.author,
          resource.authorId,
          serializer: IriMappingWithBaseUriProviderTestAuthorIdMapper(
            baseUriProvider: () => resource.baseUri,
          ),
        )
        .build();
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class IriMappingWithProviderPropertyTestAuthorIdMapper
    implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/(?<genre>[^/]*)/(?<authorId>[^/]*)$',
  );

  final String Function() _genreProvider;

  /// Constructor
  const IriMappingWithProviderPropertyTestAuthorIdMapper({
    required String Function() genreProvider,
  }) : _genreProvider = genreProvider;

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['authorId']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final authorId = iriTermValue.toString();
    final genre = _genreProvider();
    return context.createIriTerm('http://example.org/${genre}/${authorId}');
  }
}

/// Generated mapper for [IriMappingWithProviderPropertyTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `IriMappingWithProviderPropertyTest`.
class IriMappingWithProviderPropertyTestMapper
    implements LocalResourceMapper<IriMappingWithProviderPropertyTest> {
  /// Constructor
  const IriMappingWithProviderPropertyTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  IriMappingWithProviderPropertyTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String genre = reader.require(SchemaBook.genre);
    final String authorId = reader.require(
      SchemaBook.author,
      deserializer: IriMappingWithProviderPropertyTestAuthorIdMapper(
        genreProvider: () =>
            throw Exception('Must not call provider for deserialization'),
      ),
    );

    return IriMappingWithProviderPropertyTest(genre: genre, authorId: authorId);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    IriMappingWithProviderPropertyTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.genre, resource.genre)
        .addValue(
          SchemaBook.author,
          resource.authorId,
          serializer: IriMappingWithProviderPropertyTestAuthorIdMapper(
            genreProvider: () => resource.genre,
          ),
        )
        .build();
  }
}

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `String`.
class IriMappingWithProvidersAndBaseUriPropertyTestAuthorIdMapper
    implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/(?<genre>[^/]*)/(?<version>[^/]*)/(?<authorId>[^/]*)$',
  );

  final String Function() _baseUriProvider;
  final String Function() _genreProvider;
  final String Function() _versionProvider;

  /// Constructor
  const IriMappingWithProvidersAndBaseUriPropertyTestAuthorIdMapper({
    required String Function() baseUriProvider,
    required String Function() genreProvider,
    required String Function() versionProvider,
  }) : _baseUriProvider = baseUriProvider,
       _genreProvider = genreProvider,
       _versionProvider = versionProvider;

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['authorId']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final authorId = iriTermValue.toString();
    final baseUri = _baseUriProvider();
    final genre = _genreProvider();
    final version = _versionProvider();
    return context.createIriTerm('${baseUri}/${genre}/${version}/${authorId}');
  }
}

/// Generated mapper for [IriMappingWithProvidersAndBaseUriPropertyTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `IriMappingWithProvidersAndBaseUriPropertyTest`.
class IriMappingWithProvidersAndBaseUriPropertyTestMapper
    implements
        LocalResourceMapper<IriMappingWithProvidersAndBaseUriPropertyTest> {
  final String Function() _baseUriProvider;

  /// Constructor
  const IriMappingWithProvidersAndBaseUriPropertyTestMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  IriTerm? get typeIri => null;

  @override
  IriMappingWithProvidersAndBaseUriPropertyTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String genre = reader.require(SchemaBook.genre);
    final String version = reader.require(SchemaBook.version);
    final String authorId = reader.require(
      SchemaBook.author,
      deserializer: IriMappingWithProvidersAndBaseUriPropertyTestAuthorIdMapper(
        baseUriProvider: _baseUriProvider,
        genreProvider: () =>
            throw Exception('Must not call provider for deserialization'),
        versionProvider: () =>
            throw Exception('Must not call provider for deserialization'),
      ),
    );

    return IriMappingWithProvidersAndBaseUriPropertyTest(
      genre: genre,
      version: version,
      authorId: authorId,
    );
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    IriMappingWithProvidersAndBaseUriPropertyTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.genre, resource.genre)
        .addValue(SchemaBook.version, resource.version)
        .addValue(
          SchemaBook.author,
          resource.authorId,
          serializer:
              IriMappingWithProvidersAndBaseUriPropertyTestAuthorIdMapper(
                baseUriProvider: _baseUriProvider,
                genreProvider: () => resource.genre,
                versionProvider: () => resource.version,
              ),
        )
        .build();
  }
}

/// Generated mapper for [IriMappingNamedMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `IriMappingNamedMapperTest`.
class IriMappingNamedMapperTestMapper
    implements LocalResourceMapper<IriMappingNamedMapperTest> {
  final IriTermMapper<String> _authorIdMapper;

  /// Constructor
  const IriMappingNamedMapperTestMapper({
    required IriTermMapper<String> iriMapper,
  }) : _authorIdMapper = iriMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  IriMappingNamedMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String authorId = reader.require(
      SchemaBook.author,
      deserializer: _authorIdMapper,
    );

    return IriMappingNamedMapperTest(authorId: authorId);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    IriMappingNamedMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.author,
          resource.authorId,
          serializer: _authorIdMapper,
        )
        .build();
  }
}

/// Generated mapper for [IriMappingMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `IriMappingMapperTest`.
class IriMappingMapperTestMapper
    implements LocalResourceMapper<IriMappingMapperTest> {
  final IriTermMapper<String> _authorIdMapper;

  /// Constructor
  const IriMappingMapperTestMapper({
    IriTermMapper<String> authorIdMapper = const IriMapperImpl(),
  }) : _authorIdMapper = authorIdMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  IriMappingMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String authorId = reader.require(
      SchemaBook.author,
      deserializer: _authorIdMapper,
    );

    return IriMappingMapperTest(authorId: authorId);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    IriMappingMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.author,
          resource.authorId,
          serializer: _authorIdMapper,
        )
        .build();
  }
}

/// Generated mapper for [IriMappingMapperInstanceTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `IriMappingMapperInstanceTest`.
class IriMappingMapperInstanceTestMapper
    implements LocalResourceMapper<IriMappingMapperInstanceTest> {
  final IriTermMapper<String> _authorIdMapper;

  /// Constructor
  const IriMappingMapperInstanceTestMapper({
    IriTermMapper<String> authorIdMapper = const IriMapperImpl(),
  }) : _authorIdMapper = authorIdMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  IriMappingMapperInstanceTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String authorId = reader.require(
      SchemaBook.author,
      deserializer: _authorIdMapper,
    );

    return IriMappingMapperInstanceTest(authorId: authorId);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    IriMappingMapperInstanceTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.author,
          resource.authorId,
          serializer: _authorIdMapper,
        )
        .build();
  }
}

/// Generated mapper for [LocalResourceMappingTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `LocalResourceMappingTest`.
class LocalResourceMappingTestMapper
    implements LocalResourceMapper<LocalResourceMappingTest> {
  final LocalResourceMapper<Object> _authorMapper;

  /// Constructor
  const LocalResourceMappingTestMapper({
    required LocalResourceMapper<Object> testLocalMapper,
  }) : _authorMapper = testLocalMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  LocalResourceMappingTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Object author = reader.require(
      SchemaBook.author,
      deserializer: _authorMapper,
    );

    return LocalResourceMappingTest(author: author);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    LocalResourceMappingTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.author, resource.author, serializer: _authorMapper)
        .build();
  }
}

/// Generated mapper for [GlobalResourceMappingTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `GlobalResourceMappingTest`.
class GlobalResourceMappingTestMapper
    implements LocalResourceMapper<GlobalResourceMappingTest> {
  final GlobalResourceMapper<Object> _publisherMapper;

  /// Constructor
  const GlobalResourceMappingTestMapper({
    required GlobalResourceMapper<Object> testGlobalMapper,
  }) : _publisherMapper = testGlobalMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  GlobalResourceMappingTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Object publisher = reader.require(
      SchemaBook.publisher,
      deserializer: _publisherMapper,
    );

    return GlobalResourceMappingTest(publisher: publisher);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    GlobalResourceMappingTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.publisher,
          resource.publisher,
          serializer: _publisherMapper,
        )
        .build();
  }
}

/// Generated mapper for [LiteralMappingTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `LiteralMappingTest`.
class LiteralMappingTestMapper
    implements LocalResourceMapper<LiteralMappingTest> {
  final LiteralTermMapper<double> _priceMapper;

  /// Constructor
  const LiteralMappingTestMapper({
    required LiteralTermMapper<double> testLiteralPriceMapper,
  }) : _priceMapper = testLiteralPriceMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  LiteralMappingTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final double price = reader.require(
      const IriTerm('http://example.org/book/price'),
      deserializer: _priceMapper,
    );

    return LiteralMappingTest(price: price);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    LiteralMappingTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('http://example.org/book/price'),
          resource.price,
          serializer: _priceMapper,
        )
        .build();
  }
}

/// Generated mapper for [LiteralMappingTestCustomDatatype] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `LiteralMappingTestCustomDatatype`.
class LiteralMappingTestCustomDatatypeMapper
    implements LocalResourceMapper<LiteralMappingTestCustomDatatype> {
  final LiteralTermMapper<double> _priceMapper;

  /// Constructor
  const LiteralMappingTestCustomDatatypeMapper({
    LiteralTermMapper<double> priceMapper = const DoubleMapper(),
  }) : _priceMapper = priceMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  LiteralMappingTestCustomDatatype fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final double price = reader.require(
      const IriTerm('http://example.org/book/price'),
      deserializer: _priceMapper,
    );

    return LiteralMappingTestCustomDatatype(price: price);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    LiteralMappingTestCustomDatatype resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('http://example.org/book/price'),
          resource.price,
          serializer: _priceMapper,
        )
        .build();
  }
}

/// Generated mapper for [CollectionNoneTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `CollectionNoneTest`.
class CollectionNoneTestMapper
    implements LocalResourceMapper<CollectionNoneTest> {
  final Mapper<List<String>> _authorsMapper;

  /// Constructor
  const CollectionNoneTestMapper({
    Mapper<List<String>> authorsMapper = const JsonLiteralStringListMapper(),
  }) : _authorsMapper = authorsMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  CollectionNoneTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> authors = reader.require(
      SchemaBook.author,
      deserializer: _authorsMapper,
    );

    return CollectionNoneTest(authors: authors);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    CollectionNoneTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.author,
          resource.authors,
          serializer: _authorsMapper,
        )
        .build();
  }
}

/// Generated mapper for [CollectionAutoTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `CollectionAutoTest`.
class CollectionAutoTestMapper
    implements LocalResourceMapper<CollectionAutoTest> {
  /// Constructor
  const CollectionAutoTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  CollectionAutoTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> authors = reader.requireCollection<List<String>, String>(
      SchemaBook.author,
      UnorderedItemsListMapper.new,
    );

    return CollectionAutoTest(authors: authors);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    CollectionAutoTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addCollection<List<String>, String>(
          SchemaBook.author,
          resource.authors,
          UnorderedItemsListMapper.new,
        )
        .build();
  }
}

/// Generated mapper for [CollectionTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `CollectionTest`.
class CollectionTestMapper implements LocalResourceMapper<CollectionTest> {
  /// Constructor
  const CollectionTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  CollectionTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final List<String> authors =
        reader.optionalCollection<List<String>, String>(
          SchemaBook.author,
          UnorderedItemsListMapper.new,
        ) ??
        [];

    return CollectionTest(authors: authors);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    CollectionTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .when(
          resource.authors != [],
          (b) => b.addCollection<List<String>, String>(
            SchemaBook.author,
            resource.authors,
            UnorderedItemsListMapper.new,
          ),
        )
        .build();
  }
}

/// Generated mapper for [CollectionIterableTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `CollectionIterableTest`.
class CollectionIterableTestMapper
    implements LocalResourceMapper<CollectionIterableTest> {
  /// Constructor
  const CollectionIterableTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  CollectionIterableTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Iterable<String> authors = reader
        .requireCollection<Iterable<String>, String>(
          SchemaBook.author,
          UnorderedItemsMapper.new,
        );

    return CollectionIterableTest(authors: authors);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    CollectionIterableTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addCollection<Iterable<String>, String>(
          SchemaBook.author,
          resource.authors,
          UnorderedItemsMapper.new,
        )
        .build();
  }
}

/// Generated mapper for [MapNoCollectionNoMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `MapNoCollectionNoMapperTest`.
class MapNoCollectionNoMapperTestMapper
    implements LocalResourceMapper<MapNoCollectionNoMapperTest> {
  /// Constructor
  const MapNoCollectionNoMapperTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  MapNoCollectionNoMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Map<String, String> reviews = reader.require(SchemaBook.reviews);

    return MapNoCollectionNoMapperTest(reviews: reviews);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    MapNoCollectionNoMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.reviews, resource.reviews)
        .build();
  }
}

/// Generated mapper for [MapLocalResourceMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `MapLocalResourceMapperTest`.
class MapLocalResourceMapperTestMapper
    implements LocalResourceMapper<MapLocalResourceMapperTest> {
  final LocalResourceMapper<MapEntry<String, String>> _reviewsMapper;

  /// Constructor
  const MapLocalResourceMapperTestMapper({
    required LocalResourceMapper<MapEntry<String, String>> mapEntryMapper,
  }) : _reviewsMapper = mapEntryMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  MapLocalResourceMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Map<String, String> reviews = reader.getMap<String, String>(
      SchemaBook.reviews,
      deserializer: _reviewsMapper,
    );

    return MapLocalResourceMapperTest(reviews: reviews);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    MapLocalResourceMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addMap<String, String>(
          SchemaBook.reviews,
          resource.reviews,
          serializer: _reviewsMapper,
        )
        .build();
  }
}

/// Generated mapper for [SetTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `SetTest`.
class SetTestMapper implements LocalResourceMapper<SetTest> {
  /// Constructor
  const SetTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  SetTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Set<String> keywords = reader.requireCollection<Set<String>, String>(
      SchemaBook.keywords,
      UnorderedItemsSetMapper.new,
    );

    return SetTest(keywords: keywords);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    SetTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addCollection<Set<String>, String>(
          SchemaBook.keywords,
          resource.keywords,
          UnorderedItemsSetMapper.new,
        )
        .build();
  }
}

/// Generated mapper for [EnumTypeTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `EnumTypeTest`.
class EnumTypeTestMapper implements LocalResourceMapper<EnumTypeTest> {
  /// Constructor
  const EnumTypeTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  EnumTypeTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final BookFormatType format = reader.require(SchemaBook.bookFormat);

    return EnumTypeTest(format: format);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    EnumTypeTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.bookFormat, resource.format)
        .build();
  }
}

/// Generated mapper for [ComplexDefaultValueTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `ComplexDefaultValueTest`.
class ComplexDefaultValueTestMapper
    implements LocalResourceMapper<ComplexDefaultValueTest> {
  final Mapper<Map<String, dynamic>> _complexValueMapper;

  /// Constructor
  const ComplexDefaultValueTestMapper({
    Mapper<Map<String, dynamic>> complexValueMapper =
        const JsonLiteralMapMapper(),
  }) : _complexValueMapper = complexValueMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  ComplexDefaultValueTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Map<String, dynamic> complexValue =
        reader.optional(
          const IriTerm('http://example.org/test/complexValue'),
          deserializer: _complexValueMapper,
        ) ??
        {'id': '1', 'name': 'Test'};

    return ComplexDefaultValueTest(complexValue: complexValue);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    ComplexDefaultValueTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .when(
          resource.complexValue != {'id': '1', 'name': 'Test'},
          (b) => b.addValue(
            const IriTerm('http://example.org/test/complexValue'),
            resource.complexValue,
            serializer: _complexValueMapper,
          ),
        )
        .build();
  }
}

/// Generated mapper for [FinalPropertyTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `FinalPropertyTest`.
class FinalPropertyTestMapper
    implements LocalResourceMapper<FinalPropertyTest> {
  /// Constructor
  const FinalPropertyTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  FinalPropertyTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String name = reader.require(SchemaBook.name);
    final String? description = reader.optional(SchemaBook.description);

    return FinalPropertyTest(name: name, description: description);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    FinalPropertyTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.name, resource.name)
        .when(
          resource.description != null,
          (b) => b.addValue(SchemaBook.description, resource.description),
        )
        .build();
  }
}

/// Generated mapper for [LatePropertyTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `LatePropertyTest`.
class LatePropertyTestMapper implements LocalResourceMapper<LatePropertyTest> {
  /// Constructor
  const LatePropertyTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  LatePropertyTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String name = reader.require(SchemaBook.name);
    final String? description = reader.optional(SchemaBook.description);

    final retval = LatePropertyTest();
    retval.name = name;
    retval.description = description;
    return retval;
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    LatePropertyTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.name, resource.name)
        .when(
          resource.description != null,
          (b) => b.addValue(SchemaBook.description, resource.description),
        )
        .build();
  }
}

/// Generated mapper for [MutablePropertyTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `MutablePropertyTest`.
class MutablePropertyTestMapper
    implements LocalResourceMapper<MutablePropertyTest> {
  /// Constructor
  const MutablePropertyTestMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  MutablePropertyTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String name = reader.require(SchemaBook.name);
    final String? description = reader.optional(SchemaBook.description);

    return MutablePropertyTest(name: name, description: description);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    MutablePropertyTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.name, resource.name)
        .when(
          resource.description != null,
          (b) => b.addValue(SchemaBook.description, resource.description),
        )
        .build();
  }
}

/// Generated mapper for [LanguageTagTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `LanguageTagTest`.
class LanguageTagTestMapper implements LocalResourceMapper<LanguageTagTest> {
  final LiteralTermMapper<String> _descriptionMapper;

  /// Constructor
  const LanguageTagTestMapper({
    LiteralTermMapper<String> descriptionMapper =
        const LanguageOverrideMapper<String>('en'),
  }) : _descriptionMapper = descriptionMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  LanguageTagTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String description = reader.require(
      SchemaBook.description,
      deserializer: _descriptionMapper,
    );

    return LanguageTagTest(description: description);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    LanguageTagTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.description,
          resource.description,
          serializer: _descriptionMapper,
        )
        .build();
  }
}

/// Generated mapper for [DatatypeTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `DatatypeTest`.
class DatatypeTestMapper implements LocalResourceMapper<DatatypeTest> {
  final LiteralTermMapper<int> _countMapper;
  final LiteralTermMapper<String> _dateMapper;

  /// Constructor
  const DatatypeTestMapper({
    LiteralTermMapper<int> countMapper = const DatatypeOverrideMapper<int>(
      Xsd.string,
    ),
    LiteralTermMapper<String> dateMapper = const DatatypeOverrideMapper<String>(
      Xsd.dateTime,
    ),
  }) : _countMapper = countMapper,
       _dateMapper = dateMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  DatatypeTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final int count = reader.require(
      SchemaBook.description,
      deserializer: _countMapper,
    );
    final String date = reader.require(
      SchemaBook.dateCreated,
      deserializer: _dateMapper,
    );

    return DatatypeTest(count: count, date: date);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    DatatypeTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.description,
          resource.count,
          serializer: _countMapper,
        )
        .addValue(
          SchemaBook.dateCreated,
          resource.date,
          serializer: _dateMapper,
        )
        .build();
  }
}

/// Generated mapper for [GlobalResourceNamedMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `GlobalResourceNamedMapperTest`.
class GlobalResourceNamedMapperTestMapper
    implements LocalResourceMapper<GlobalResourceNamedMapperTest> {
  final GlobalResourceMapper<Object> _publisherMapper;

  /// Constructor
  const GlobalResourceNamedMapperTestMapper({
    required GlobalResourceMapper<Object> testNamedMapper,
  }) : _publisherMapper = testNamedMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  GlobalResourceNamedMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Object publisher = reader.require(
      SchemaBook.publisher,
      deserializer: _publisherMapper,
    );

    return GlobalResourceNamedMapperTest(publisher: publisher);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    GlobalResourceNamedMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.publisher,
          resource.publisher,
          serializer: _publisherMapper,
        )
        .build();
  }
}

/// Generated mapper for [LiteralNamedMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `LiteralNamedMapperTest`.
class LiteralNamedMapperTestMapper
    implements LocalResourceMapper<LiteralNamedMapperTest> {
  final LiteralTermMapper<String> _isbnMapper;

  /// Constructor
  const LiteralNamedMapperTestMapper({
    required LiteralTermMapper<String> testCustomMapper,
  }) : _isbnMapper = testCustomMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  LiteralNamedMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String isbn = reader.require(
      SchemaBook.isbn,
      deserializer: _isbnMapper,
    );

    return LiteralNamedMapperTest(isbn: isbn);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    LiteralNamedMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.isbn, resource.isbn, serializer: _isbnMapper)
        .build();
  }
}

/// Generated mapper for [LiteralTypeMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `LiteralTypeMapperTest`.
class LiteralTypeMapperTestMapper
    implements LocalResourceMapper<LiteralTypeMapperTest> {
  final LiteralTermMapper<double> _priceMapper;

  /// Constructor
  const LiteralTypeMapperTestMapper({
    LiteralTermMapper<double> priceMapper = const LiteralDoubleMapperImpl(),
  }) : _priceMapper = priceMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  LiteralTypeMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final double price = reader.require(
      SchemaBook.bookFormat,
      deserializer: _priceMapper,
    );

    return LiteralTypeMapperTest(price: price);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    LiteralTypeMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.bookFormat,
          resource.price,
          serializer: _priceMapper,
        )
        .build();
  }
}

/// Generated mapper for [GlobalResourceTypeMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `GlobalResourceTypeMapperTest`.
class GlobalResourceTypeMapperTestMapper
    implements LocalResourceMapper<GlobalResourceTypeMapperTest> {
  final GlobalResourceMapper<Publisher> _publisherMapper;

  /// Constructor
  const GlobalResourceTypeMapperTestMapper({
    GlobalResourceMapper<Publisher> publisherMapper =
        const GlobalPublisherMapperImpl(),
  }) : _publisherMapper = publisherMapper;

  @override
  IriTerm? get typeIri => SchemaBook.classIri;

  @override
  GlobalResourceTypeMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Publisher publisher = reader.require(
      SchemaBook.publisher,
      deserializer: _publisherMapper,
    );

    return GlobalResourceTypeMapperTest(publisher: publisher);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    GlobalResourceTypeMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.publisher,
          resource.publisher,
          serializer: _publisherMapper,
        )
        .build();
  }
}

/// Generated mapper for [GlobalResourceMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `GlobalResourceMapperTest`.
class GlobalResourceMapperTestMapper
    implements LocalResourceMapper<GlobalResourceMapperTest> {
  final GlobalResourceMapper<Object> _publisherMapper;

  /// Constructor
  const GlobalResourceMapperTestMapper({
    GlobalResourceMapper<Object> publisherMapper =
        const GlobalPublisherMapperImpl(),
  }) : _publisherMapper = publisherMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  GlobalResourceMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Object publisher = reader.require(
      SchemaBook.publisher,
      deserializer: _publisherMapper,
    );

    return GlobalResourceMapperTest(publisher: publisher);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    GlobalResourceMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.publisher,
          resource.publisher,
          serializer: _publisherMapper,
        )
        .build();
  }
}

/// Generated mapper for [GlobalResourceInstanceMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `GlobalResourceInstanceMapperTest`.
class GlobalResourceInstanceMapperTestMapper
    implements LocalResourceMapper<GlobalResourceInstanceMapperTest> {
  final GlobalResourceMapper<Object> _publisherMapper;

  /// Constructor
  const GlobalResourceInstanceMapperTestMapper({
    GlobalResourceMapper<Object> publisherMapper =
        const GlobalPublisherMapperImpl(),
  }) : _publisherMapper = publisherMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  GlobalResourceInstanceMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Object publisher = reader.require(
      SchemaBook.publisher,
      deserializer: _publisherMapper,
    );

    return GlobalResourceInstanceMapperTest(publisher: publisher);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    GlobalResourceInstanceMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.publisher,
          resource.publisher,
          serializer: _publisherMapper,
        )
        .build();
  }
}

/// Generated mapper for [LocalResourceMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `LocalResourceMapperTest`.
class LocalResourceMapperTestMapper
    implements LocalResourceMapper<LocalResourceMapperTest> {
  final LocalResourceMapper<Author> _authorMapper;

  /// Constructor
  const LocalResourceMapperTestMapper({
    LocalResourceMapper<Author> authorMapper =
        const LocalResourceAuthorMapperImpl(),
  }) : _authorMapper = authorMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  LocalResourceMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Author author = reader.require(
      SchemaBook.author,
      deserializer: _authorMapper,
    );

    return LocalResourceMapperTest(author: author);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    LocalResourceMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.author, resource.author, serializer: _authorMapper)
        .build();
  }
}

/// Generated mapper for [LocalResourceMapperObjectPropertyTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `LocalResourceMapperObjectPropertyTest`.
class LocalResourceMapperObjectPropertyTestMapper
    implements LocalResourceMapper<LocalResourceMapperObjectPropertyTest> {
  final LocalResourceMapper<Object> _authorMapper;

  /// Constructor
  const LocalResourceMapperObjectPropertyTestMapper({
    LocalResourceMapper<Object> authorMapper =
        const LocalResourceAuthorMapperImpl(),
  }) : _authorMapper = authorMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  LocalResourceMapperObjectPropertyTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Object author = reader.require(
      SchemaBook.author,
      deserializer: _authorMapper,
    );

    return LocalResourceMapperObjectPropertyTest(author: author);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    LocalResourceMapperObjectPropertyTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.author, resource.author, serializer: _authorMapper)
        .build();
  }
}

/// Generated mapper for [LocalResourceInstanceMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `LocalResourceInstanceMapperTest`.
class LocalResourceInstanceMapperTestMapper
    implements LocalResourceMapper<LocalResourceInstanceMapperTest> {
  final LocalResourceMapper<Author> _authorMapper;

  /// Constructor
  const LocalResourceInstanceMapperTestMapper({
    LocalResourceMapper<Author> authorMapper =
        const LocalResourceAuthorMapperImpl(),
  }) : _authorMapper = authorMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  LocalResourceInstanceMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Author author = reader.require(
      SchemaBook.author,
      deserializer: _authorMapper,
    );

    return LocalResourceInstanceMapperTest(author: author);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    LocalResourceInstanceMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.author, resource.author, serializer: _authorMapper)
        .build();
  }
}

/// Generated mapper for [LocalResourceInstanceMapperObjectPropertyTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `LocalResourceInstanceMapperObjectPropertyTest`.
class LocalResourceInstanceMapperObjectPropertyTestMapper
    implements
        LocalResourceMapper<LocalResourceInstanceMapperObjectPropertyTest> {
  final LocalResourceMapper<Object> _authorMapper;

  /// Constructor
  const LocalResourceInstanceMapperObjectPropertyTestMapper({
    LocalResourceMapper<Object> authorMapper =
        const LocalResourceAuthorMapperImpl(),
  }) : _authorMapper = authorMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  LocalResourceInstanceMapperObjectPropertyTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final Object author = reader.require(
      SchemaBook.author,
      deserializer: _authorMapper,
    );

    return LocalResourceInstanceMapperObjectPropertyTest(author: author);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    LocalResourceInstanceMapperObjectPropertyTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.author, resource.author, serializer: _authorMapper)
        .build();
  }
}

/// Generated mapper for [LiteralMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `LiteralMapperTest`.
class LiteralMapperTestMapper
    implements LocalResourceMapper<LiteralMapperTest> {
  final LiteralTermMapper<int> _pageCountMapper;

  /// Constructor
  const LiteralMapperTestMapper({
    LiteralTermMapper<int> pageCountMapper = const IntMapper(),
  }) : _pageCountMapper = pageCountMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  LiteralMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final int pageCount = reader.require(
      SchemaBook.numberOfPages,
      deserializer: _pageCountMapper,
    );

    return LiteralMapperTest(pageCount: pageCount);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    LiteralMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          SchemaBook.numberOfPages,
          resource.pageCount,
          serializer: _pageCountMapper,
        )
        .build();
  }
}

/// Generated mapper for [LiteralInstanceMapperTest] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `LiteralInstanceMapperTest`.
class LiteralInstanceMapperTestMapper
    implements LocalResourceMapper<LiteralInstanceMapperTest> {
  final LiteralTermMapper<String> _isbnMapper;

  /// Constructor
  const LiteralInstanceMapperTestMapper({
    LiteralTermMapper<String> isbnMapper = const LiteralStringMapperImpl(),
  }) : _isbnMapper = isbnMapper;

  @override
  IriTerm? get typeIri => null;

  @override
  LiteralInstanceMapperTest fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String isbn = reader.require(
      SchemaBook.isbn,
      deserializer: _isbnMapper,
    );

    return LiteralInstanceMapperTest(isbn: isbn);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    LiteralInstanceMapperTest resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.isbn, resource.isbn, serializer: _isbnMapper)
        .build();
  }
}

/// Generated mapper for [BookFormatType] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type BookFormatType.
class BookFormatTypeMapper implements LiteralTermMapper<BookFormatType> {
  final IriTerm? datatype = null;

  const BookFormatTypeMapper();

  @override
  BookFormatType fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) => switch (term.value) {
    'hardcover' => BookFormatType.hardcover,
    'paperback' => BookFormatType.paperback,
    'ebook' => BookFormatType.ebook,
    'audioBook' => BookFormatType.audioBook,
    _ => throw DeserializationException(
      'Unknown BookFormatType literal value: ${term.value}',
    ),
  };

  @override
  LiteralTerm toRdfTerm(
    BookFormatType value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    BookFormatType.hardcover => LiteralTerm('hardcover'),
    BookFormatType.paperback => LiteralTerm('paperback'),
    BookFormatType.ebook => LiteralTerm('ebook'),
    BookFormatType.audioBook => LiteralTerm('audioBook'),
  };
}
