// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/provided_as_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'provided_as_test_models.dart';

/// Generated mapper for [Section] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Section`.
class SectionMapper implements GlobalResourceMapper<Section> {
  static final RegExp _regex = RegExp(
    r'^(?<documentIri>.*)/sections/(?<sectionId>[^/]*)$',
  );

  final String Function() _documentIriProvider;

  /// Constructor
  const SectionMapper({required String Function() documentIriProvider})
    : _documentIriProvider = documentIriProvider;

  @override
  IriTerm? get typeIri => ProvidedAsVocab.Section;

  @override
  Section fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final sectionId = iriParts['sectionId'];
    if (sectionId == null) {
      throw DeserializationException(
        'Missing required IRI part: sectionId in IRI ${subject.value}',
      );
    }
    final String title = reader.require(ProvidedAsVocab.sectionTitle);

    final retval = Section();
    retval.sectionId = sectionId;
    retval.title = title;
    return retval;
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Section resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(ProvidedAsVocab.sectionTitle, resource.title)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Section resource) {
    final sectionId = resource.sectionId;
    final documentIri = _documentIriProvider();
    return '${documentIri}/sections/${sectionId}';
  }
}

/// Generated mapper for [Document] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Document`.
class DocumentMapper implements GlobalResourceMapper<Document> {
  static final RegExp _regex = RegExp(
    r'^(?<baseUri>.*)/documents/(?<docId>[^/]*)$',
  );

  final String Function() _baseUriProvider;

  /// Constructor
  const DocumentMapper({required String Function() baseUriProvider})
    : _baseUriProvider = baseUriProvider;

  @override
  IriTerm? get typeIri => ProvidedAsVocab.Document;

  @override
  Document fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final docId = iriParts['docId'];
    if (docId == null) {
      throw DeserializationException(
        'Missing required IRI part: docId in IRI ${subject.value}',
      );
    }
    final List<Section> sections = reader
        .requireCollection<List<Section>, Section>(
          ProvidedAsVocab.hasSection,
          UnorderedItemsListMapper.new,
          itemDeserializer: SectionMapper(
            documentIriProvider: () =>
                throw Exception('Must not call provider for deserialization'),
          ),
        );
    final String? relatedDocRef = reader.optional(
      ProvidedAsVocab.relatedDocument,
    );

    final retval = Document();
    retval.docId = docId;
    retval.sections = sections;
    retval.relatedDocRef = relatedDocRef;
    return retval;
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Document resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addCollection<List<Section>, Section>(
          ProvidedAsVocab.hasSection,
          resource.sections,
          UnorderedItemsListMapper.new,
          itemSerializer: SectionMapper(
            documentIriProvider: () => subject.value,
          ),
        )
        .when(
          resource.relatedDocRef != null,
          (b) => b.addValue(
            ProvidedAsVocab.relatedDocument,
            resource.relatedDocRef,
          ),
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Document resource) {
    final docId = resource.docId;
    final baseUri = _baseUriProvider();
    return '${baseUri}/documents/${docId}';
  }
}
